#!/usr/bin/env node
/**
 * Error Handler with GitHub Integration
 * Creates GitHub issues for errors and manages error documentation
 * Part of the Restart, Rebuild, and Relaunch Enhancement
 */

const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');

class GitHubErrorHandler {
  constructor(options = {}) {
    this.verbose = options.verbose || false;
    this.dryRun = options.dryRun || false;
    this.logFile = path.join(process.cwd(), 'logs', 'error-handler.log');
    this.ensureLogDirectory();
    
    // GitHub configuration
    this.githubConfig = {
      owner: 'mytech-today-now',
      repo: 'business_scraper',
      apiUrl: 'https://api.github.com'
    };
  }

  ensureLogDirectory() {
    const logDir = path.dirname(this.logFile);
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }
  }

  log(message, level = 'INFO') {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] [${level}] ${message}`;
    
    if (this.verbose || level === 'ERROR' || level === 'WARN') {
      console.log(logMessage);
    }
    
    try {
      fs.appendFileSync(this.logFile, logMessage + '\n');
    } catch (error) {
      console.error('Failed to write to log file:', error.message);
    }
  }

  async executeCommand(command, description) {
    return new Promise((resolve, reject) => {
      this.log(`Executing: ${command}`, 'DEBUG');
      
      exec(command, { timeout: 30000 }, (error, stdout, stderr) => {
        if (error) {
          this.log(`${description} failed: ${error.message}`, 'ERROR');
          if (stderr) this.log(`stderr: ${stderr}`, 'ERROR');
          reject(error);
        } else {
          this.log(`${description} completed successfully`, 'SUCCESS');
          resolve(stdout);
        }
      });
    });
  }

  generateIssueTitle(error) {
    const timestamp = new Date().toISOString().split('T')[0];
    const errorType = error.type || 'General Error';
    const component = error.component || 'Application';
    
    return `[${timestamp}] ${errorType}: ${component} - ${error.summary || 'Restart Process Failure'}`;
  }

  generateIssueBody(error) {
    const timestamp = new Date().toISOString();
    
    let body = `# Error Report\n\n`;
    body += `**Generated:** ${timestamp}\n`;
    body += `**Component:** ${error.component || 'Application Restart Process'}\n`;
    body += `**Error Type:** ${error.type || 'Process Failure'}\n`;
    body += `**Severity:** ${error.severity || 'High'}\n\n`;
    
    body += `## Summary\n\n`;
    body += `${error.summary || 'An error occurred during the restart, rebuild, and relaunch process.'}\n\n`;
    
    if (error.description) {
      body += `## Description\n\n`;
      body += `${error.description}\n\n`;
    }
    
    body += `## Error Details\n\n`;
    body += `**Error Message:**\n`;
    body += `\`\`\`\n${error.message || 'No specific error message available'}\n\`\`\`\n\n`;
    
    if (error.stack) {
      body += `**Stack Trace:**\n`;
      body += `\`\`\`\n${error.stack}\n\`\`\`\n\n`;
    }
    
    body += `## Reproduction Steps\n\n`;
    if (error.reproductionSteps) {
      error.reproductionSteps.forEach((step, index) => {
        body += `${index + 1}. ${step}\n`;
      });
    } else {
      body += `1. Run the restart, rebuild, and relaunch process\n`;
      body += `2. Observe the error during execution\n`;
    }
    body += `\n`;
    
    body += `## Expected Behavior\n\n`;
    body += `${error.expectedBehavior || 'The restart process should complete successfully without errors.'}\n\n`;
    
    body += `## Actual Behavior\n\n`;
    body += `${error.actualBehavior || 'The process failed with the error described above.'}\n\n`;
    
    body += `## Environment Information\n\n`;
    body += `- **OS:** Windows\n`;
    body += `- **Node.js Version:** ${process.version}\n`;
    body += `- **Application Version:** ${this.getApplicationVersion()}\n`;
    body += `- **Timestamp:** ${timestamp}\n\n`;
    
    if (error.logs) {
      body += `## Relevant Logs\n\n`;
      body += `\`\`\`\n${error.logs}\n\`\`\`\n\n`;
    }
    
    body += `## Additional Context\n\n`;
    body += `${error.additionalContext || 'This issue was automatically generated by the error handling system.'}\n\n`;
    
    body += `## Resolution Checklist\n\n`;
    body += `- [ ] Identify root cause of the error\n`;
    body += `- [ ] Implement fix for the issue\n`;
    body += `- [ ] Add tests to prevent regression\n`;
    body += `- [ ] Update documentation if needed\n`;
    body += `- [ ] Verify fix in development environment\n`;
    body += `- [ ] Deploy fix to production\n`;
    body += `- [ ] Close this issue with resolution details\n`;
    
    return body;
  }

  getApplicationVersion() {
    try {
      const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
      return packageJson.version || 'Unknown';
    } catch (error) {
      return 'Unknown';
    }
  }

  getIssueLabels(error) {
    const labels = ['bug', 'automated-issue'];
    
    // Add severity label
    switch (error.severity?.toLowerCase()) {
      case 'critical':
        labels.push('critical', 'priority-high');
        break;
      case 'high':
        labels.push('priority-high');
        break;
      case 'medium':
        labels.push('priority-medium');
        break;
      case 'low':
        labels.push('priority-low');
        break;
      default:
        labels.push('priority-medium');
    }
    
    // Add component labels
    if (error.component) {
      switch (error.component.toLowerCase()) {
        case 'build':
          labels.push('build-system');
          break;
        case 'test':
          labels.push('testing');
          break;
        case 'deployment':
          labels.push('deployment');
          break;
        case 'security':
          labels.push('security');
          break;
        default:
          labels.push('enhancement');
      }
    }
    
    // Add type labels
    if (error.type) {
      switch (error.type.toLowerCase()) {
        case 'build error':
          labels.push('build-failure');
          break;
        case 'test failure':
          labels.push('test-failure');
          break;
        case 'deployment error':
          labels.push('deployment-failure');
          break;
        case 'security issue':
          labels.push('security-vulnerability');
          break;
      }
    }
    
    return labels;
  }

  async createGitHubIssue(error) {
    this.log('Creating GitHub issue for error...');
    
    if (this.dryRun) {
      this.log('[DRY RUN] Would create GitHub issue:', 'INFO');
      this.log(`Title: ${this.generateIssueTitle(error)}`, 'INFO');
      this.log(`Labels: ${this.getIssueLabels(error).join(', ')}`, 'INFO');
      return { success: true, dryRun: true };
    }
    
    const issueData = {
      title: this.generateIssueTitle(error),
      body: this.generateIssueBody(error),
      labels: this.getIssueLabels(error),
      assignees: ['mytech-today-now']
    };
    
    try {
      // Create the issue using GitHub CLI if available
      const issueJson = JSON.stringify(issueData);
      const tempFile = path.join(process.cwd(), 'temp-issue.json');
      
      fs.writeFileSync(tempFile, issueJson);
      
      try {
        const result = await this.executeCommand(
          `gh issue create --repo ${this.githubConfig.owner}/${this.githubConfig.repo} --title "${issueData.title}" --body-file temp-issue-body.txt --label "${issueData.labels.join(',')}" --assignee ${issueData.assignees.join(',')}`,
          'GitHub issue creation'
        );
        
        // Clean up temp files
        if (fs.existsSync(tempFile)) fs.unlinkSync(tempFile);
        if (fs.existsSync('temp-issue-body.txt')) fs.unlinkSync('temp-issue-body.txt');
        
        this.log('GitHub issue created successfully', 'SUCCESS');
        return { success: true, result };
        
      } catch (ghError) {
        this.log('GitHub CLI not available, using curl fallback...', 'WARN');
        
        // Fallback to curl if GitHub CLI is not available
        const curlCommand = `curl -X POST -H "Accept: application/vnd.github.v3+json" -H "Authorization: token $GITHUB_TOKEN" ${this.githubConfig.apiUrl}/repos/${this.githubConfig.owner}/${this.githubConfig.repo}/issues -d @${tempFile}`;
        
        const result = await this.executeCommand(curlCommand, 'GitHub issue creation via curl');
        
        // Clean up temp file
        if (fs.existsSync(tempFile)) fs.unlinkSync(tempFile);
        
        this.log('GitHub issue created successfully via curl', 'SUCCESS');
        return { success: true, result };
      }
      
    } catch (error) {
      this.log(`Failed to create GitHub issue: ${error.message}`, 'ERROR');
      return { success: false, error: error.message };
    }
  }

  async handleError(error) {
    this.log('=== Error Handler Started ===');
    const startTime = Date.now();
    
    try {
      // Log the error
      this.log(`Handling error: ${error.message || 'Unknown error'}`, 'ERROR');
      
      // Create GitHub issue
      const issueResult = await this.createGitHubIssue(error);
      
      // Generate local error report
      const reportPath = this.generateLocalErrorReport(error);
      
      const duration = Date.now() - startTime;
      this.log(`=== Error Handler Completed in ${duration}ms ===`, 'SUCCESS');
      
      return {
        success: true,
        duration,
        issueCreated: issueResult.success,
        reportPath,
        message: 'Error handled successfully'
      };
      
    } catch (handlerError) {
      const duration = Date.now() - startTime;
      this.log(`=== Error Handler Failed after ${duration}ms ===`, 'ERROR');
      this.log(`Handler Error: ${handlerError.message}`, 'ERROR');
      
      return {
        success: false,
        duration,
        error: handlerError.message,
        message: 'Error handler failed'
      };
    }
  }

  generateLocalErrorReport(error) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const reportPath = path.join(process.cwd(), 'logs', `error-report-${timestamp}.md`);
    
    const report = this.generateIssueBody(error);
    
    try {
      fs.writeFileSync(reportPath, report);
      this.log(`Local error report generated: ${reportPath}`, 'SUCCESS');
      return reportPath;
    } catch (writeError) {
      this.log(`Failed to write error report: ${writeError.message}`, 'ERROR');
      return null;
    }
  }
}

// CLI interface
if (require.main === module) {
  const args = process.argv.slice(2);
  const verbose = args.includes('--verbose') || args.includes('-v');
  const dryRun = args.includes('--dry-run') || args.includes('-d');
  
  if (args.includes('--help') || args.includes('-h')) {
    console.log(`
Error Handler with GitHub Integration
Usage: node scripts/error-handler-github.js [options] [error-json]

Options:
  --verbose, -v     Enable verbose logging
  --dry-run, -d     Show what would be done without actually creating issues
  --help, -h        Show this help message

Examples:
  node scripts/error-handler-github.js --verbose
  echo '{"message":"Test error","type":"Build Error","severity":"high"}' | node scripts/error-handler-github.js
`);
    process.exit(0);
  }
  
  const handler = new GitHubErrorHandler({ verbose, dryRun });
  
  // Read error from stdin or command line
  let errorData = {};
  
  if (args.length > 0 && !args[0].startsWith('--')) {
    try {
      errorData = JSON.parse(args[0]);
    } catch (parseError) {
      errorData = { message: args[0], type: 'General Error', severity: 'medium' };
    }
  } else {
    // Default test error
    errorData = {
      message: 'Test error from error handler',
      type: 'Test Error',
      component: 'Error Handler',
      severity: 'low',
      summary: 'Testing the error handling system',
      description: 'This is a test error to verify the error handling system is working correctly.'
    };
  }
  
  handler.handleError(errorData)
    .then(result => {
      if (result.success) {
        console.log('✅ Error handled successfully');
        if (result.issueCreated) {
          console.log('📝 GitHub issue created');
        }
        if (result.reportPath) {
          console.log(`📄 Local report: ${result.reportPath}`);
        }
        process.exit(0);
      } else {
        console.error('❌ Error handling failed:', result.message);
        process.exit(1);
      }
    })
    .catch(error => {
      console.error('❌ Unexpected error in error handler:', error.message);
      process.exit(1);
    });
}

module.exports = GitHubErrorHandler;
