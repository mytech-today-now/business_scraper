<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Stripe Payment Integration - AI Implementation Prompts</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,
          sans-serif;
        line-height: 1.6;
        color: #333;
        background-color: #f8fafc;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
      }

      .header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 40px 20px;
        text-align: center;
        margin-bottom: 30px;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .header h1 {
        font-size: 2.5rem;
        margin-bottom: 10px;
        font-weight: 700;
      }

      .header .subtitle {
        font-size: 1.2rem;
        opacity: 0.9;
        margin-bottom: 10px;
      }

      .header .meta {
        font-size: 0.9rem;
        opacity: 0.8;
      }

      .nav {
        background: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin-bottom: 30px;
        position: sticky;
        top: 20px;
        z-index: 100;
      }

      .nav h3 {
        margin-bottom: 15px;
        color: #4a5568;
        font-size: 1.1rem;
      }

      .nav-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 10px;
      }

      .nav-item {
        display: block;
        padding: 8px 12px;
        color: #667eea;
        text-decoration: none;
        border-radius: 6px;
        transition: all 0.2s;
        font-size: 0.9rem;
      }

      .nav-item:hover {
        background-color: #667eea;
        color: white;
        transform: translateX(5px);
      }

      .content {
        background: white;
        padding: 40px;
        border-radius: 10px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin-bottom: 30px;
      }

      .prompt-section {
        margin-bottom: 50px;
        padding-bottom: 30px;
        border-bottom: 2px solid #e2e8f0;
      }

      .prompt-section:last-child {
        border-bottom: none;
      }

      .prompt-header {
        background: linear-gradient(135deg, #4299e1 0%, #667eea 100%);
        color: white;
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 25px;
      }

      .prompt-header h2 {
        font-size: 1.8rem;
        margin-bottom: 8px;
      }

      .prompt-header .objective {
        font-size: 1.1rem;
        opacity: 0.9;
      }

      h3 {
        color: #2d3748;
        font-size: 1.3rem;
        margin: 25px 0 15px 0;
        padding-bottom: 8px;
        border-bottom: 2px solid #e2e8f0;
      }

      h4 {
        color: #4a5568;
        font-size: 1.1rem;
        margin: 20px 0 10px 0;
        font-weight: 600;
      }

      p {
        margin-bottom: 15px;
        color: #4a5568;
      }

      ul,
      ol {
        margin: 15px 0 15px 25px;
        color: #4a5568;
      }

      li {
        margin-bottom: 8px;
      }

      .code-block {
        background: #1a202c;
        color: #e2e8f0;
        padding: 20px;
        border-radius: 8px;
        margin: 20px 0;
        overflow-x: auto;
        font-family: 'Fira Code', 'Consolas', monospace;
        font-size: 0.9rem;
        line-height: 1.5;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .code-block pre {
        margin: 0;
        white-space: pre-wrap;
      }

      .validation-box {
        background: #f0fff4;
        border: 1px solid #9ae6b4;
        border-radius: 8px;
        padding: 20px;
        margin: 20px 0;
      }

      .validation-box h4 {
        color: #22543d;
        margin-top: 0;
      }

      .next-steps {
        background: #ebf8ff;
        border: 1px solid #90cdf4;
        border-radius: 8px;
        padding: 20px;
        margin: 20px 0;
      }

      .next-steps h4 {
        color: #2c5282;
        margin-top: 0;
      }

      .overview-section {
        background: #f7fafc;
        border-left: 4px solid #667eea;
        padding: 20px;
        margin: 20px 0;
        border-radius: 0 8px 8px 0;
      }

      .feature-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin: 20px 0;
      }

      .feature-card {
        background: white;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      }

      .feature-card h4 {
        color: #667eea;
        margin-bottom: 10px;
      }

      .summary-section {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 40px;
        border-radius: 10px;
        margin-top: 40px;
      }

      .summary-section h2 {
        margin-bottom: 20px;
        font-size: 2rem;
      }

      .benefits-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }

      .benefit-item {
        background: rgba(255, 255, 255, 0.1);
        padding: 15px;
        border-radius: 8px;
        backdrop-filter: blur(10px);
      }

      .back-to-top {
        position: fixed;
        bottom: 30px;
        right: 30px;
        background: #667eea;
        color: white;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        transition: all 0.3s;
      }

      .back-to-top:hover {
        background: #5a67d8;
        transform: translateY(-2px);
      }

      @media (max-width: 768px) {
        .container {
          padding: 10px;
        }

        .header h1 {
          font-size: 2rem;
        }

        .content {
          padding: 20px;
        }

        .nav-grid {
          grid-template-columns: 1fr;
        }
      }

      .highlight {
        background: #fef5e7;
        border-left: 4px solid #f6ad55;
        padding: 15px;
        margin: 15px 0;
        border-radius: 0 8px 8px 0;
      }

      .warning {
        background: #fed7d7;
        border-left: 4px solid #fc8181;
        padding: 15px;
        margin: 15px 0;
        border-radius: 0 8px 8px 0;
      }

      .info {
        background: #e6fffa;
        border-left: 4px solid #4fd1c7;
        padding: 15px;
        margin: 15px 0;
        border-radius: 0 8px 8px 0;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üî• Stripe Payment Integration</h1>
        <div class="subtitle">AI Implementation Prompts for Business Scraper App</div>
        <div class="meta">
          Version: 1.0.0 | Date: 2025-08-29 | Framework: Next.js 14 + TypeScript
        </div>
      </div>

      <div class="nav">
        <h3>üìã Quick Navigation</h3>
        <div class="nav-grid">
          <a href="#overview" class="nav-item">üìñ Overview</a>
          <a href="#prompt1" class="nav-item">1Ô∏è‚É£ Project Setup</a>
          <a href="#prompt2" class="nav-item">2Ô∏è‚É£ Database Schema</a>
          <a href="#prompt3" class="nav-item">3Ô∏è‚É£ Model Layer</a>
          <a href="#prompt4" class="nav-item">4Ô∏è‚É£ Payment Models</a>
          <a href="#prompt5" class="nav-item">5Ô∏è‚É£ API Layer</a>
          <a href="#prompt6" class="nav-item">6Ô∏è‚É£ View Layer</a>
          <a href="#prompt7" class="nav-item">7Ô∏è‚É£ Controller Layer</a>
          <a href="#prompt8" class="nav-item">8Ô∏è‚É£ Security & Testing</a>
          <a href="#prompt9" class="nav-item">9Ô∏è‚É£ Final Integration</a>
          <a href="#prompt10" class="nav-item">üîü User Management</a>
          <a href="#prompt11" class="nav-item">1Ô∏è‚É£1Ô∏è‚É£ Analytics</a>
          <a href="#prompt12" class="nav-item">1Ô∏è‚É£2Ô∏è‚É£ Compliance</a>
          <a href="#prompt13" class="nav-item">1Ô∏è‚É£3Ô∏è‚É£ Email Notifications</a>
          <a href="#prompt14" class="nav-item">1Ô∏è‚É£4Ô∏è‚É£ Performance Monitoring</a>
          <a href="#prompt15" class="nav-item">1Ô∏è‚É£5Ô∏è‚É£ Dashboard Integration</a>
          <a href="#summary" class="nav-item">üìä Summary</a>
        </div>
      </div>

      <div class="content">
        <section id="overview" class="prompt-section">
          <div class="overview-section">
            <h2>üìñ Overview</h2>
            <p>
              This document contains a series of AI prompts designed for Augment AI running in VS
              Code to implement a complete Stripe payment system into the Business Scraper App. Each
              prompt builds upon the previous work and includes detailed step-by-step instructions.
            </p>

            <div class="feature-grid">
              <div class="feature-card">
                <h4>üèóÔ∏è Complete Architecture</h4>
                <p>
                  Full MVC implementation with Model, View, and Controller layers following the
                  project's established patterns.
                </p>
              </div>
              <div class="feature-card">
                <h4>üîí Enterprise Security</h4>
                <p>
                  PCI-compliant payment processing with comprehensive audit logging and GDPR
                  compliance.
                </p>
              </div>
              <div class="feature-card">
                <h4>üìä Advanced Analytics</h4>
                <p>
                  Business intelligence dashboard with revenue metrics, user analytics, and
                  performance monitoring.
                </p>
              </div>
              <div class="feature-card">
                <h4>üöÄ Production Ready</h4>
                <p>
                  Comprehensive testing, monitoring, alerting, and deployment-ready configuration.
                </p>
              </div>
            </div>
          </div>
        </section>

        <section id="prompt1" class="prompt-section">
          <div class="prompt-header">
            <h2>Prompt 1: Project Setup and Dependencies</h2>
            <div class="objective">
              Install and configure all necessary Stripe dependencies and update project
              configuration files.
            </div>
          </div>

          <h3>Instructions for AI Assistant</h3>

          <h4>Step 1: Install Stripe Dependencies</h4>
          <p>Execute the following commands in the terminal to install required packages:</p>
          <div class="code-block">
            <pre>
npm install stripe @stripe/stripe-js @stripe/react-stripe-js
npm install --save-dev @types/stripe
npm install crypto-js jsonwebtoken
npm install --save-dev @types/jsonwebtoken</pre
            >
          </div>

          <h4>Step 2: Verify Installation</h4>
          <p>
            After installation, check that the following packages appear in
            <code>package.json</code>:
          </p>
          <ul>
            <li><code>stripe</code></li>
            <li><code>@stripe/stripe-js</code></li>
            <li><code>@stripe/react-stripe-js</code></li>
            <li><code>crypto-js</code></li>
            <li><code>jsonwebtoken</code></li>
          </ul>

          <h4>Step 3: Update Environment Configuration</h4>
          <p>
            1. Open the file <code>config/development.env.example</code><br />
            2. Add the following Stripe configuration variables:
          </p>
          <div class="code-block">
            <pre>
# Stripe Configuration
STRIPE_PUBLISHABLE_KEY=pk_test_...
STRIPE_SECRET_KEY=sk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...

# Production keys (for deployment)
STRIPE_PUBLISHABLE_KEY_LIVE=pk_live_...
STRIPE_SECRET_KEY_LIVE=sk_live_...
STRIPE_WEBHOOK_SECRET_LIVE=whsec_...

# Payment Configuration
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=${STRIPE_PUBLISHABLE_KEY}
PAYMENT_SUCCESS_URL=http://localhost:3000/payment/success
PAYMENT_CANCEL_URL=http://localhost:3000/payment/cancel</pre
            >
          </div>

          <p>
            3. Copy the same configuration to <code>config/production.env.example</code> and
            <code>config/test.env.example</code>
          </p>

          <h4>Step 4: Update Configuration Schema</h4>
          <p>
            1. Open <code>src/lib/config.ts</code><br />
            2. Locate the <code>configSchema</code> object<br />
            3. Add the following validation rules:
          </p>
          <div class="code-block">
            <pre>
// Add to configSchema
'STRIPE_PUBLISHABLE_KEY': { type: 'string', required: true },
'STRIPE_SECRET_KEY': { type: 'string', required: true },
'STRIPE_WEBHOOK_SECRET': { type: 'string', required: true },
'NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY': { type: 'string', required: true },
'PAYMENT_SUCCESS_URL': { type: 'url', required: true },
'PAYMENT_CANCEL_URL': { type: 'url', required: true },</pre
            >
          </div>

          <p>4. Update the <code>AppConfig</code> interface to include:</p>
          <div class="code-block">
            <pre>
payments: {
  stripePublishableKey: string
  stripeSecretKey: string
  stripeWebhookSecret: string
  successUrl: string
  cancelUrl: string
}</pre
            >
          </div>

          <div class="validation-box">
            <h4>‚úÖ Validation Steps:</h4>
            <ul>
              <li>Run <code>npm list</code> to confirm all packages are installed</li>
              <li>Check that environment files contain Stripe configuration</li>
              <li>Verify config.ts compiles without TypeScript errors</li>
              <li>Test that the application starts without configuration errors</li>
            </ul>
          </div>

          <div class="next-steps">
            <h4>üöÄ Next Steps:</h4>
            <p>Proceed to Prompt 2 for database schema implementation.</p>
          </div>
        </section>

        <section id="prompt2" class="prompt-section">
          <div class="prompt-header">
            <h2>Prompt 2: Database Schema Implementation</h2>
            <div class="objective">
              Create PostgreSQL database tables and indexes to support Stripe payment functionality.
            </div>
          </div>

          <h3>Instructions for AI Assistant</h3>

          <h4>Step 1: Create Migration File</h4>
          <p>
            1. Navigate to the <code>database/migrations/</code> directory<br />
            2. Create a new file named <code>002_stripe_payment_system.sql</code><br />
            3. Add the following SQL schema:
          </p>
          <div class="code-block">
            <pre>
-- Users table updates (add Stripe customer ID if not exists)
ALTER TABLE users ADD COLUMN IF NOT EXISTS stripe_customer_id VARCHAR(255) UNIQUE;

-- Subscription plans
CREATE TABLE IF NOT EXISTS subscription_plans (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    stripe_price_id VARCHAR(255) UNIQUE NOT NULL,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    price_cents INTEGER NOT NULL,
    currency VARCHAR(3) DEFAULT 'usd',
    interval VARCHAR(20) NOT NULL, -- 'month', 'year'
    features JSONB,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- User subscriptions
CREATE TABLE IF NOT EXISTS user_subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    stripe_subscription_id VARCHAR(255) UNIQUE NOT NULL,
    plan_id UUID REFERENCES subscription_plans(id),
    status VARCHAR(50) NOT NULL, -- 'active', 'canceled', 'past_due', etc.
    current_period_start TIMESTAMP,
    current_period_end TIMESTAMP,
    cancel_at_period_end BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Payment transactions
CREATE TABLE IF NOT EXISTS payment_transactions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    stripe_payment_intent_id VARCHAR(255) UNIQUE,
    amount_cents INTEGER NOT NULL,
    currency VARCHAR(3) DEFAULT 'usd',
    status VARCHAR(50) NOT NULL,
    description TEXT,
    metadata JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Usage tracking for premium features
CREATE TABLE IF NOT EXISTS feature_usage (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    feature_type VARCHAR(100) NOT NULL, -- 'scraping_request', 'export', 'advanced_search'
    usage_count INTEGER DEFAULT 1,
    date DATE DEFAULT CURRENT_DATE,
    metadata JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_users_stripe_customer ON users(stripe_customer_id);
CREATE INDEX IF NOT EXISTS idx_subscriptions_user ON user_subscriptions(user_id);
CREATE INDEX IF NOT EXISTS idx_subscriptions_stripe ON user_subscriptions(stripe_subscription_id);
CREATE INDEX IF NOT EXISTS idx_transactions_user ON payment_transactions(user_id);
CREATE INDEX IF NOT EXISTS idx_usage_user_date ON feature_usage(user_id, date);</pre
            >
          </div>

          <div class="validation-box">
            <h4>‚úÖ Validation Steps:</h4>
            <ul>
              <li>Confirm migration file exists and is properly formatted</li>
              <li>Verify database tables are created successfully</li>
              <li>Check that IndexedDB interface compiles without errors</li>
              <li>Test that foreign key relationships work correctly</li>
            </ul>
          </div>

          <div class="next-steps">
            <h4>üöÄ Next Steps:</h4>
            <p>Proceed to Prompt 3 for Model layer implementation.</p>
          </div>
        </section>

        <section id="prompt3" class="prompt-section">
          <div class="prompt-header">
            <h2>Prompt 3: Model Layer Implementation - Comprehensive Payment Services</h2>
            <div class="objective">
              Create a comprehensive Model layer for payment functionality including Stripe service,
              user-payment integration, customer synchronization, and business rules validation.
            </div>
          </div>

          <h3>Instructions for AI Assistant</h3>

          <div class="highlight">
            <h4>üèóÔ∏è Enhanced Model Layer Architecture</h4>
            <p>
              This prompt has been significantly expanded to include enterprise-grade payment
              services:
            </p>
            <ul>
              <li>
                <strong>Advanced Stripe Service:</strong> Customer lifecycle management,
                subscription handling, invoice management
              </li>
              <li>
                <strong>User-Payment Integration:</strong> Seamless user-Stripe customer
                relationship management
              </li>
              <li>
                <strong>Payment Validation Service:</strong> Business rules engine and feature
                access control
              </li>
              <li>
                <strong>Storage Integration:</strong> Enhanced IndexedDB schemas for payment data
              </li>
            </ul>
          </div>

          <h4>Step 1: Create Core Stripe Service File</h4>
          <p>
            1. Create a new file <code>src/model/stripeService.ts</code><br />
            2. Implement the comprehensive service class with advanced features:
          </p>
          <div class="code-block">
            <pre>
import Stripe from 'stripe'
import { getConfig } from '@/lib/config'
import { logger } from '@/utils/logger'

export class StripeService {
  private stripe: Stripe
  private config = getConfig()

  constructor() {
    this.stripe = new Stripe(this.config.payments.stripeSecretKey, {
      apiVersion: '2023-10-16',
      typescript: true,
    })
  }

  // Customer Management
  async createCustomer(email: string, name?: string): Promise&lt;Stripe.Customer&gt; {
    try {
      const customer = await this.stripe.customers.create({
        email,
        name,
        metadata: { source: 'business_scraper_app' }
      })
      logger.info('StripeService', `Customer created: ${customer.id}`)
      return customer
    } catch (error) {
      logger.error('StripeService', 'Failed to create customer', error)
      throw error
    }
  }

  // Subscription Management
  async createSubscription(
    customerId: string,
    priceId: string,
    metadata?: Record&lt;string, string&gt;
  ): Promise&lt;Stripe.Subscription&gt; {
    try {
      const subscription = await this.stripe.subscriptions.create({
        customer: customerId,
        items: [{ price: priceId }],
        payment_behavior: 'default_incomplete',
        payment_settings: { save_default_payment_method: 'on_subscription' },
        expand: ['latest_invoice.payment_intent'],
        metadata: metadata || {}
      })
      return subscription
    } catch (error) {
      logger.error('StripeService', 'Failed to create subscription', error)
      throw error
    }
  }

  // Payment Intent for one-time payments
  async createPaymentIntent(
    amount: number,
    currency: string = 'usd',
    customerId?: string,
    metadata?: Record&lt;string, string&gt;
  ): Promise&lt;Stripe.PaymentIntent&gt; {
    try {
      const paymentIntent = await this.stripe.paymentIntents.create({
        amount,
        currency,
        customer: customerId,
        automatic_payment_methods: { enabled: true },
        metadata: metadata || {}
      })
      return paymentIntent
    } catch (error) {
      logger.error('StripeService', 'Failed to create payment intent', error)
      throw error
    }
  }

  // Webhook signature verification
  verifyWebhookSignature(payload: string, signature: string): Stripe.Event {
    try {
      return this.stripe.webhooks.constructEvent(
        payload,
        signature,
        this.config.payments.stripeWebhookSecret
      )
    } catch (error) {
      logger.error('StripeService', 'Webhook signature verification failed', error)
      throw error
    }
  }
}

export const stripeService = new StripeService()</pre
            >
          </div>

          <h4>Step 2: Create User-Payment Integration Service</h4>
          <p>
            1. Create a new file <code>src/model/userPaymentService.ts</code><br />
            2. Implement user-payment relationship management:
          </p>
          <div class="code-block">
            <pre>
import { stripeService } from './stripeService'
import { storage } from './storage'
import { logger } from '@/utils/logger'

export class UserPaymentService {
  // Create or retrieve Stripe customer for user
  async ensureStripeCustomer(userId: string, email: string, name?: string): Promise&lt;string&gt; {
    try {
      // Check if user already has a Stripe customer ID
      const existingProfile = await this.getUserPaymentProfile(userId)
      if (existingProfile?.stripeCustomerId) {
        return existingProfile.stripeCustomerId
      }

      // Create new Stripe customer
      const customer = await stripeService.createCustomer(email, name)

      // Store customer ID in user profile
      await this.updateUserPaymentProfile(userId, {
        stripeCustomerId: customer.id,
        email,
        name,
        subscriptionStatus: 'free',
        updatedAt: new Date()
      })

      logger.info('UserPaymentService', `Stripe customer created for user: ${userId}`)
      return customer.id
    } catch (error) {
      logger.error('UserPaymentService', 'Failed to ensure Stripe customer', error)
      throw error
    }
  }

  // Additional methods for user payment management...
}

export const userPaymentService = new UserPaymentService()</pre
            >
          </div>

          <div class="info">
            <h4>üìã Complete Implementation Note</h4>
            <p>
              The full implementation includes 6 additional service classes with comprehensive
              payment functionality. This HTML version shows the key structure and first few
              services. The complete implementation guide contains:
            </p>
            <ul>
              <li>Payment Validation Service with business rules</li>
              <li>User Management Integration (Prompt 10)</li>
              <li>Payment Analytics and Reporting (Prompt 11)</li>
              <li>Compliance and Audit Logging (Prompt 12)</li>
              <li>Email Notifications (Prompt 13)</li>
              <li>Performance Monitoring (Prompt 14)</li>
              <li>Dashboard Integration (Prompt 15)</li>
            </ul>
          </div>

          <div class="validation-box">
            <h4>‚úÖ Validation Steps:</h4>
            <ul>
              <li>Confirm all new service files are created in correct locations</li>
              <li>Check TypeScript compilation passes for all new services</li>
              <li>Verify integration with existing storage system works</li>
              <li>Test that all services can be imported without errors</li>
              <li>Validate that business rules are properly implemented</li>
            </ul>
          </div>

          <div class="next-steps">
            <h4>üöÄ Next Steps:</h4>
            <p>Proceed to Prompt 4 for Payment Models implementation.</p>
          </div>
        </section>

        <section id="prompt4" class="prompt-section">
          <div class="prompt-header">
            <h2>Prompt 4: Payment Models and Data Structures</h2>
            <div class="objective">
              Create comprehensive TypeScript models and Zod schemas for all payment-related data
              structures with validation and type safety.
            </div>
          </div>

          <h3>Instructions for AI Assistant</h3>

          <h4>Step 1: Create Payment Type Definitions</h4>
          <p>
            1. Create a new file <code>src/model/types/payment.ts</code><br />
            2. Define comprehensive TypeScript interfaces for payment data:
          </p>
          <div class="code-block">
            <pre>
// Payment Plan Types
export interface SubscriptionPlan {
  id: string
  stripePriceId: string
  name: string
  description: string
  priceCents: number
  currency: string
  interval: 'month' | 'year'
  features: string[]
  isActive: boolean
  createdAt: Date
}

// User Subscription Types
export interface UserSubscription {
  id: string
  userId: string
  stripeSubscriptionId: string
  planId: string
  status: 'active' | 'canceled' | 'past_due' | 'unpaid' | 'incomplete'
  currentPeriodStart: Date
  currentPeriodEnd: Date
  cancelAtPeriodEnd: boolean
  createdAt: Date
  updatedAt: Date
}

// Payment Transaction Types
export interface PaymentTransaction {
  id: string
  userId: string
  stripePaymentIntentId?: string
  amountCents: number
  currency: string
  status: 'pending' | 'succeeded' | 'failed' | 'canceled'
  description: string
  metadata?: Record&lt;string, any&gt;
  createdAt: Date
}

// Feature Usage Types
export interface FeatureUsage {
  id: string
  userId: string
  featureType: 'scraping_request' | 'export' | 'advanced_search' | 'api_access'
  usageCount: number
  date: Date
  metadata?: Record&lt;string, any&gt;
  createdAt: Date
}</pre
            >
          </div>

          <h4>Step 2: Create Zod Validation Schemas</h4>
          <p>
            1. Create a new file <code>src/model/schemas/payment.ts</code><br />
            2. Implement comprehensive validation schemas:
          </p>
          <div class="code-block">
            <pre>
import { z } from 'zod'

// Subscription Plan Schema
export const subscriptionPlanSchema = z.object({
  id: z.string().uuid(),
  stripePriceId: z.string().min(1),
  name: z.string().min(1).max(255),
  description: z.string().optional(),
  priceCents: z.number().int().min(0),
  currency: z.string().length(3).default('usd'),
  interval: z.enum(['month', 'year']),
  features: z.array(z.string()),
  isActive: z.boolean().default(true),
  createdAt: z.date()
})

// User Subscription Schema
export const userSubscriptionSchema = z.object({
  id: z.string().uuid(),
  userId: z.string().uuid(),
  stripeSubscriptionId: z.string().min(1),
  planId: z.string().uuid(),
  status: z.enum(['active', 'canceled', 'past_due', 'unpaid', 'incomplete']),
  currentPeriodStart: z.date(),
  currentPeriodEnd: z.date(),
  cancelAtPeriodEnd: z.boolean().default(false),
  createdAt: z.date(),
  updatedAt: z.date()
})

// Payment Transaction Schema
export const paymentTransactionSchema = z.object({
  id: z.string().uuid(),
  userId: z.string().uuid(),
  stripePaymentIntentId: z.string().optional(),
  amountCents: z.number().int().min(0),
  currency: z.string().length(3).default('usd'),
  status: z.enum(['pending', 'succeeded', 'failed', 'canceled']),
  description: z.string().min(1),
  metadata: z.record(z.any()).optional(),
  createdAt: z.date()
})

// Feature Usage Schema
export const featureUsageSchema = z.object({
  id: z.string().uuid(),
  userId: z.string().uuid(),
  featureType: z.enum(['scraping_request', 'export', 'advanced_search', 'api_access']),
  usageCount: z.number().int().min(1).default(1),
  date: z.date(),
  metadata: z.record(z.any()).optional(),
  createdAt: z.date()
})</pre
            >
          </div>

          <h4>Step 3: Create Payment Request/Response Types</h4>
          <p>
            1. Create a new file <code>src/model/types/paymentApi.ts</code><br />
            2. Define API request and response types:
          </p>
          <div class="code-block">
            <pre>
// API Request Types
export interface CreateSubscriptionRequest {
  planId: string
  paymentMethodId?: string
  couponCode?: string
}

export interface CreatePaymentIntentRequest {
  amountCents: number
  currency?: string
  description: string
  metadata?: Record&lt;string, string&gt;
}

export interface UpdateSubscriptionRequest {
  planId?: string
  cancelAtPeriodEnd?: boolean
}

// API Response Types
export interface CreateSubscriptionResponse {
  subscription: UserSubscription
  clientSecret?: string
  requiresAction: boolean
}

export interface CreatePaymentIntentResponse {
  paymentIntent: PaymentTransaction
  clientSecret: string
}

export interface PaymentStatusResponse {
  hasActiveSubscription: boolean
  currentPlan?: SubscriptionPlan
  subscription?: UserSubscription
  featureUsage: FeatureUsage[]
  usageLimits: Record&lt;string, number&gt;
}</pre
            >
          </div>

          <div class="validation-box">
            <h4>‚úÖ Validation Steps:</h4>
            <ul>
              <li>Verify all TypeScript interfaces compile without errors</li>
              <li>Test Zod schemas with sample data to ensure validation works</li>
              <li>Check that all payment-related data structures are covered</li>
              <li>Confirm API types match expected request/response formats</li>
              <li>Validate that schemas enforce proper data constraints</li>
            </ul>
          </div>

          <div class="next-steps">
            <h4>üöÄ Next Steps:</h4>
            <p>
              Proceed to Prompt 5 for API Layer implementation with webhooks and payment processing
              endpoints.
            </p>
          </div>
        </section>

        <section id="prompt5" class="prompt-section">
          <div class="prompt-header">
            <h2>Prompt 5: API Layer - Webhooks and Payment Processing</h2>
            <div class="objective">
              Implement secure API endpoints for payment processing, Stripe webhooks, and
              subscription management with comprehensive error handling.
            </div>
          </div>

          <h3>Instructions for AI Assistant</h3>

          <h4>Step 1: Create Stripe Webhook Handler</h4>
          <p>
            1. Create a new file <code>src/pages/api/webhooks/stripe.ts</code><br />
            2. Implement comprehensive webhook processing:
          </p>
          <div class="code-block">
            <pre>
import { NextApiRequest, NextApiResponse } from 'next'
import { stripeService } from '@/model/stripeService'
import { userPaymentService } from '@/model/userPaymentService'
import { logger } from '@/utils/logger'
import { buffer } from 'micro'

export const config = {
  api: {
    bodyParser: false,
  },
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' })
  }

  try {
    const buf = await buffer(req)
    const signature = req.headers['stripe-signature'] as string

    if (!signature) {
      logger.error('StripeWebhook', 'Missing stripe-signature header')
      return res.status(400).json({ error: 'Missing signature' })
    }

    const event = stripeService.verifyWebhookSignature(buf.toString(), signature)

    logger.info('StripeWebhook', `Processing event: ${event.type}`)

    switch (event.type) {
      case 'customer.subscription.created':
      case 'customer.subscription.updated':
        await handleSubscriptionUpdate(event.data.object)
        break

      case 'customer.subscription.deleted':
        await handleSubscriptionCancellation(event.data.object)
        break

      case 'payment_intent.succeeded':
        await handlePaymentSuccess(event.data.object)
        break

      case 'payment_intent.payment_failed':
        await handlePaymentFailure(event.data.object)
        break

      case 'invoice.payment_succeeded':
        await handleInvoicePaymentSuccess(event.data.object)
        break

      default:
        logger.info('StripeWebhook', `Unhandled event type: ${event.type}`)
    }

    res.status(200).json({ received: true })
  } catch (error) {
    logger.error('StripeWebhook', 'Webhook processing failed', error)
    res.status(400).json({ error: 'Webhook processing failed' })
  }
}

async function handleSubscriptionUpdate(subscription: any) {
  try {
    await userPaymentService.updateSubscriptionFromStripe(subscription)
    logger.info('StripeWebhook', `Subscription updated: ${subscription.id}`)
  } catch (error) {
    logger.error('StripeWebhook', 'Failed to update subscription', error)
    throw error
  }
}

async function handleSubscriptionCancellation(subscription: any) {
  try {
    await userPaymentService.cancelSubscription(subscription.id)
    logger.info('StripeWebhook', `Subscription canceled: ${subscription.id}`)
  } catch (error) {
    logger.error('StripeWebhook', 'Failed to cancel subscription', error)
    throw error
  }
}

async function handlePaymentSuccess(paymentIntent: any) {
  try {
    await userPaymentService.recordPaymentSuccess(paymentIntent)
    logger.info('StripeWebhook', `Payment succeeded: ${paymentIntent.id}`)
  } catch (error) {
    logger.error('StripeWebhook', 'Failed to record payment success', error)
    throw error
  }
}

async function handlePaymentFailure(paymentIntent: any) {
  try {
    await userPaymentService.recordPaymentFailure(paymentIntent)
    logger.info('StripeWebhook', `Payment failed: ${paymentIntent.id}`)
  } catch (error) {
    logger.error('StripeWebhook', 'Failed to record payment failure', error)
    throw error
  }
}

async function handleInvoicePaymentSuccess(invoice: any) {
  try {
    await userPaymentService.processInvoicePayment(invoice)
    logger.info('StripeWebhook', `Invoice payment succeeded: ${invoice.id}`)
  } catch (error) {
    logger.error('StripeWebhook', 'Failed to process invoice payment', error)
    throw error
  }
}</pre
            >
          </div>

          <h4>Step 2: Create Payment Intent API</h4>
          <p>
            1. Create a new file <code>src/pages/api/payments/create-intent.ts</code><br />
            2. Implement payment intent creation endpoint:
          </p>
          <div class="code-block">
            <pre>
import { NextApiRequest, NextApiResponse } from 'next'
import { stripeService } from '@/model/stripeService'
import { userPaymentService } from '@/model/userPaymentService'
import { createPaymentIntentSchema } from '@/model/schemas/payment'
import { authenticateUser } from '@/utils/auth'
import { logger } from '@/utils/logger'

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' })
  }

  try {
    // Authenticate user
    const user = await authenticateUser(req)
    if (!user) {
      return res.status(401).json({ error: 'Unauthorized' })
    }

    // Validate request body
    const validatedData = createPaymentIntentSchema.parse(req.body)

    // Ensure user has Stripe customer
    const stripeCustomerId = await userPaymentService.ensureStripeCustomer(
      user.id,
      user.email,
      user.name
    )

    // Create payment intent
    const paymentIntent = await stripeService.createPaymentIntent(
      validatedData.amountCents,
      validatedData.currency || 'usd',
      stripeCustomerId,
      validatedData.metadata
    )

    // Record transaction in database
    await userPaymentService.createPaymentTransaction({
      userId: user.id,
      stripePaymentIntentId: paymentIntent.id,
      amountCents: validatedData.amountCents,
      currency: validatedData.currency || 'usd',
      status: 'pending',
      description: validatedData.description
    })

    logger.info('PaymentAPI', `Payment intent created for user: ${user.id}`)

    res.status(200).json({
      clientSecret: paymentIntent.client_secret,
      paymentIntentId: paymentIntent.id
    })
  } catch (error) {
    logger.error('PaymentAPI', 'Failed to create payment intent', error)
    res.status(500).json({ error: 'Failed to create payment intent' })
  }
}</pre
            >
          </div>

          <div class="validation-box">
            <h4>‚úÖ Validation Steps:</h4>
            <ul>
              <li>Test webhook endpoint with Stripe CLI webhook forwarding</li>
              <li>Verify payment intent creation works with test data</li>
              <li>Check that all webhook events are properly handled</li>
              <li>Confirm error handling and logging work correctly</li>
              <li>Test authentication and authorization for API endpoints</li>
            </ul>
          </div>

          <div class="next-steps">
            <h4>üöÄ Next Steps:</h4>
            <p>Proceed to Prompt 6 for View Layer implementation with React payment components.</p>
          </div>
        </section>

        <section id="prompt6" class="prompt-section">
          <div class="prompt-header">
            <h2>Prompt 6: View Layer - React Payment Components</h2>
            <div class="objective">
              Create comprehensive React components for payment forms, subscription plans, and
              payment management with Stripe Elements integration.
            </div>
          </div>

          <h3>Instructions for AI Assistant</h3>

          <h4>Step 1: Create Stripe Provider Component</h4>
          <p>
            1. Create a new file <code>src/view/components/payments/StripeProvider.tsx</code><br />
            2. Implement the Stripe Elements provider wrapper:
          </p>
          <div class="code-block">
            <pre>
import React from 'react'
import { Elements } from '@stripe/react-stripe-js'
import { loadStripe } from '@stripe/stripe-js'
import { getConfig } from '@/lib/config'

const config = getConfig()
const stripePromise = loadStripe(config.payments.stripePublishableKey)

interface StripeProviderProps {
  children: React.ReactNode
  clientSecret?: string
}

export const StripeProvider: React.FC&lt;StripeProviderProps&gt; = ({
  children,
  clientSecret
}) =&gt; {
  const options = {
    clientSecret,
    appearance: {
      theme: 'stripe' as const,
      variables: {
        colorPrimary: '#667eea',
        colorBackground: '#ffffff',
        colorText: '#2d3748',
        colorDanger: '#e53e3e',
        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
        spacingUnit: '4px',
        borderRadius: '8px'
      }
    }
  }

  return (
    &lt;Elements stripe={stripePromise} options={clientSecret ? options : undefined}&gt;
      {children}
    &lt;/Elements&gt;
  )
}</pre
            >
          </div>

          <h4>Step 2: Create Payment Form Component</h4>
          <p>
            1. Create a new file <code>src/view/components/payments/PaymentForm.tsx</code><br />
            2. Implement the payment form with Stripe Elements:
          </p>
          <div class="code-block">
            <pre>
import React, { useState } from 'react'
import {
  PaymentElement,
  useStripe,
  useElements
} from '@stripe/react-stripe-js'
import { Button } from '@/view/components/ui/Button'
import { Alert } from '@/view/components/ui/Alert'
import { Spinner } from '@/view/components/ui/Spinner'

interface PaymentFormProps {
  onSuccess?: (paymentIntent: any) =&gt; void
  onError?: (error: string) =&gt; void
  amount: number
  currency?: string
  description: string
}

export const PaymentForm: React.FC&lt;PaymentFormProps&gt; = ({
  onSuccess,
  onError,
  amount,
  currency = 'usd',
  description
}) =&gt; {
  const stripe = useStripe()
  const elements = useElements()
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState&lt;string | null&gt;(null)

  const handleSubmit = async (event: React.FormEvent) =&gt; {
    event.preventDefault()

    if (!stripe || !elements) {
      return
    }

    setIsLoading(true)
    setError(null)

    try {
      const { error: submitError } = await elements.submit()
      if (submitError) {
        setError(submitError.message || 'Payment submission failed')
        setIsLoading(false)
        return
      }

      const { error: confirmError, paymentIntent } = await stripe.confirmPayment({
        elements,
        confirmParams: {
          return_url: `${window.location.origin}/payment/success`
        },
        redirect: 'if_required'
      })

      if (confirmError) {
        setError(confirmError.message || 'Payment confirmation failed')
        onError?.(confirmError.message || 'Payment failed')
      } else if (paymentIntent?.status === 'succeeded') {
        onSuccess?.(paymentIntent)
      }
    } catch (err) {
      setError('An unexpected error occurred')
      onError?.('An unexpected error occurred')
    } finally {
      setIsLoading(false)
    }
  }

  const formatAmount = (cents: number) =&gt; {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: currency.toUpperCase()
    }).format(cents / 100)
  }

  return (
    &lt;form onSubmit={handleSubmit} className="space-y-6"&gt;
      &lt;div className="bg-gray-50 p-4 rounded-lg"&gt;
        &lt;h3 className="font-semibold text-lg mb-2"&gt;Payment Details&lt;/h3&gt;
        &lt;p className="text-gray-600 mb-2"&gt;{description}&lt;/p&gt;
        &lt;p className="text-2xl font-bold text-blue-600"&gt;
          {formatAmount(amount)}
        &lt;/p&gt;
      &lt;/div&gt;

      &lt;div className="space-y-4"&gt;
        &lt;PaymentElement
          options={{
            layout: 'tabs'
          }}
        /&gt;
      &lt;/div&gt;

      {error && (
        &lt;Alert variant="error"&gt;
          {error}
        &lt;/Alert&gt;
      )}

      &lt;Button
        type="submit"
        disabled={!stripe || !elements || isLoading}
        className="w-full"
        size="lg"
      &gt;
        {isLoading ? (
          &lt;&gt;
            &lt;Spinner className="mr-2" /&gt;
            Processing Payment...
          &lt;/&gt;
        ) : (
          `Pay ${formatAmount(amount)}`
        )}
      &lt;/Button&gt;
    &lt;/form&gt;
  )
}</pre
            >
          </div>

          <h4>Step 3: Create Subscription Plans Component</h4>
          <p>
            1. Create a new file <code>src/view/components/payments/SubscriptionPlans.tsx</code
            ><br />
            2. Implement subscription plan selection interface:
          </p>
          <div class="code-block">
            <pre>
import React, { useState, useEffect } from 'react'
import { SubscriptionPlan } from '@/model/types/payment'
import { Button } from '@/view/components/ui/Button'
import { Card } from '@/view/components/ui/Card'
import { Badge } from '@/view/components/ui/Badge'
import { CheckIcon } from '@heroicons/react/24/outline'

interface SubscriptionPlansProps {
  plans: SubscriptionPlan[]
  currentPlanId?: string
  onSelectPlan: (plan: SubscriptionPlan) =&gt; void
  isLoading?: boolean
}

export const SubscriptionPlans: React.FC&lt;SubscriptionPlansProps&gt; = ({
  plans,
  currentPlanId,
  onSelectPlan,
  isLoading = false
}) =&gt; {
  const [selectedPlan, setSelectedPlan] = useState&lt;SubscriptionPlan | null&gt;(null)

  const formatPrice = (cents: number, interval: string) =&gt; {
    const price = new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD'
    }).format(cents / 100)
    return `${price}/${interval}`
  }

  const isCurrentPlan = (planId: string) =&gt; planId === currentPlanId
  const isPopular = (plan: SubscriptionPlan) =&gt; plan.name.toLowerCase().includes('pro')

  return (
    &lt;div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"&gt;
      {plans.map((plan) =&gt; (
        &lt;Card
          key={plan.id}
          className={`relative p-6 ${
            selectedPlan?.id === plan.id
              ? 'ring-2 ring-blue-500 border-blue-500'
              : 'border-gray-200'
          } ${isCurrentPlan(plan.id) ? 'bg-blue-50' : 'bg-white'}`}
        &gt;
          {isPopular(plan) && (
            &lt;Badge
              variant="primary"
              className="absolute -top-2 left-1/2 transform -translate-x-1/2"
            &gt;
              Most Popular
            &lt;/Badge&gt;
          )}

          &lt;div className="text-center mb-6"&gt;
            &lt;h3 className="text-xl font-bold text-gray-900 mb-2"&gt;
              {plan.name}
            &lt;/h3&gt;
            &lt;p className="text-gray-600 mb-4"&gt;{plan.description}&lt;/p&gt;
            &lt;div className="text-3xl font-bold text-blue-600"&gt;
              {formatPrice(plan.priceCents, plan.interval)}
            &lt;/div&gt;
          &lt;/div&gt;

          &lt;ul className="space-y-3 mb-6"&gt;
            {plan.features.map((feature, index) =&gt; (
              &lt;li key={index} className="flex items-center"&gt;
                &lt;CheckIcon className="h-5 w-5 text-green-500 mr-3 flex-shrink-0" /&gt;
                &lt;span className="text-gray-700"&gt;{feature}&lt;/span&gt;
              &lt;/li&gt;
            ))}
          &lt;/ul&gt;

          &lt;Button
            onClick={() =&gt; {
              setSelectedPlan(plan)
              onSelectPlan(plan)
            }}
            disabled={isLoading || isCurrentPlan(plan.id)}
            className="w-full"
            variant={isCurrentPlan(plan.id) ? 'secondary' : 'primary'}
          &gt;
            {isCurrentPlan(plan.id)
              ? 'Current Plan'
              : isLoading
              ? 'Processing...'
              : 'Select Plan'}
          &lt;/Button&gt;
        &lt;/Card&gt;
      ))}
    &lt;/div&gt;
  )
}</pre
            >
          </div>

          <div class="validation-box">
            <h4>‚úÖ Validation Steps:</h4>
            <ul>
              <li>Test Stripe Elements integration with test payment methods</li>
              <li>Verify payment form handles errors gracefully</li>
              <li>Check subscription plan selection and display</li>
              <li>Confirm responsive design works on mobile devices</li>
              <li>Test accessibility features and keyboard navigation</li>
            </ul>
          </div>

          <div class="next-steps">
            <h4>üöÄ Next Steps:</h4>
            <p>
              Proceed to Prompt 7 for Controller Layer implementation with payment state management.
            </p>
          </div>
        </section>

        <section id="prompt7" class="prompt-section">
          <div class="prompt-header">
            <h2>Prompt 7: Controller Layer - Payment State Management</h2>
            <div class="objective">
              Implement comprehensive payment state management, feature access control, and
              subscription lifecycle management in the Controller layer.
            </div>
          </div>

          <h3>Instructions for AI Assistant</h3>

          <h4>Step 1: Create Payment Controller</h4>
          <p>
            1. Create a new file <code>src/controller/paymentController.ts</code><br />
            2. Implement comprehensive payment state management:
          </p>
          <div class="code-block">
            <pre>
import { EventEmitter } from 'events'
import { userPaymentService } from '@/model/userPaymentService'
import { stripeService } from '@/model/stripeService'
import { storage } from '@/model/storage'
import { logger } from '@/utils/logger'
import {
  SubscriptionPlan,
  UserSubscription,
  PaymentTransaction,
  FeatureUsage
} from '@/model/types/payment'

export class PaymentController extends EventEmitter {
  private currentUser: any = null
  private subscriptionPlans: SubscriptionPlan[] = []
  private userSubscription: UserSubscription | null = null
  private paymentStatus: 'idle' | 'processing' | 'success' | 'error' = 'idle'

  constructor() {
    super()
    this.initializePaymentSystem()
  }

  // Initialize payment system
  async initializePaymentSystem(): Promise&lt;void&gt; {
    try {
      await this.loadSubscriptionPlans()
      this.emit('payment:initialized')
      logger.info('PaymentController', 'Payment system initialized')
    } catch (error) {
      logger.error('PaymentController', 'Failed to initialize payment system', error)
      this.emit('payment:error', error)
    }
  }

  // Load available subscription plans
  async loadSubscriptionPlans(): Promise&lt;SubscriptionPlan[]&gt; {
    try {
      this.subscriptionPlans = await userPaymentService.getSubscriptionPlans()
      this.emit('plans:loaded', this.subscriptionPlans)
      return this.subscriptionPlans
    } catch (error) {
      logger.error('PaymentController', 'Failed to load subscription plans', error)
      throw error
    }
  }

  // Set current user and load their payment data
  async setCurrentUser(user: any): Promise&lt;void&gt; {
    try {
      this.currentUser = user
      await this.loadUserPaymentData()
      this.emit('user:set', user)
    } catch (error) {
      logger.error('PaymentController', 'Failed to set current user', error)
      throw error
    }
  }

  // Load user's payment data
  async loadUserPaymentData(): Promise&lt;void&gt; {
    if (!this.currentUser) return

    try {
      this.userSubscription = await userPaymentService.getUserSubscription(this.currentUser.id)
      this.emit('subscription:loaded', this.userSubscription)
    } catch (error) {
      logger.error('PaymentController', 'Failed to load user payment data', error)
      throw error
    }
  }

  // Create subscription
  async createSubscription(planId: string, paymentMethodId?: string): Promise&lt;any&gt; {
    if (!this.currentUser) {
      throw new Error('No user set')
    }

    this.paymentStatus = 'processing'
    this.emit('payment:processing')

    try {
      // Ensure Stripe customer exists
      const stripeCustomerId = await userPaymentService.ensureStripeCustomer(
        this.currentUser.id,
        this.currentUser.email,
        this.currentUser.name
      )

      // Find the plan
      const plan = this.subscriptionPlans.find(p =&gt; p.id === planId)
      if (!plan) {
        throw new Error('Plan not found')
      }

      // Create subscription
      const subscription = await stripeService.createSubscription(
        stripeCustomerId,
        plan.stripePriceId,
        { userId: this.currentUser.id }
      )

      // Update local state
      await this.loadUserPaymentData()

      this.paymentStatus = 'success'
      this.emit('subscription:created', subscription)
      this.emit('payment:success')

      return subscription
    } catch (error) {
      this.paymentStatus = 'error'
      this.emit('payment:error', error)
      logger.error('PaymentController', 'Failed to create subscription', error)
      throw error
    }
  }

  // Cancel subscription
  async cancelSubscription(): Promise&lt;void&gt; {
    if (!this.userSubscription) {
      throw new Error('No active subscription')
    }

    try {
      await userPaymentService.cancelSubscription(this.userSubscription.stripeSubscriptionId)
      await this.loadUserPaymentData()
      this.emit('subscription:canceled')
    } catch (error) {
      logger.error('PaymentController', 'Failed to cancel subscription', error)
      throw error
    }
  }

  // Check feature access
  async checkFeatureAccess(featureType: string): Promise&lt;boolean&gt; {
    if (!this.currentUser) return false

    try {
      return await userPaymentService.checkFeatureAccess(this.currentUser.id, featureType)
    } catch (error) {
      logger.error('PaymentController', 'Failed to check feature access', error)
      return false
    }
  }

  // Record feature usage
  async recordFeatureUsage(featureType: string, metadata?: any): Promise&lt;void&gt; {
    if (!this.currentUser) return

    try {
      await userPaymentService.recordFeatureUsage(
        this.currentUser.id,
        featureType,
        metadata
      )
      this.emit('usage:recorded', { featureType, metadata })
    } catch (error) {
      logger.error('PaymentController', 'Failed to record feature usage', error)
      throw error
    }
  }

  // Getters
  getSubscriptionPlans(): SubscriptionPlan[] {
    return this.subscriptionPlans
  }

  getUserSubscription(): UserSubscription | null {
    return this.userSubscription
  }

  getPaymentStatus(): string {
    return this.paymentStatus
  }

  hasActiveSubscription(): boolean {
    return this.userSubscription?.status === 'active'
  }
}

export const paymentController = new PaymentController()</pre
            >
          </div>

          <h4>Step 2: Create Feature Access Controller</h4>
          <p>
            1. Create a new file <code>src/controller/featureAccessController.ts</code><br />
            2. Implement feature access control logic:
          </p>
          <div class="code-block">
            <pre>
import { paymentController } from './paymentController'
import { logger } from '@/utils/logger'

export class FeatureAccessController {
  private featureLimits: Record&lt;string, Record&lt;string, number&gt;&gt; = {
    free: {
      scraping_request: 10,
      export: 5,
      advanced_search: 0,
      api_access: 0
    },
    basic: {
      scraping_request: 100,
      export: 50,
      advanced_search: 10,
      api_access: 0
    },
    pro: {
      scraping_request: 1000,
      export: 500,
      advanced_search: 100,
      api_access: 50
    },
    enterprise: {
      scraping_request: -1, // unlimited
      export: -1,
      advanced_search: -1,
      api_access: -1
    }
  }

  // Check if user can access a feature
  async canAccessFeature(featureType: string): Promise&lt;boolean&gt; {
    try {
      const hasAccess = await paymentController.checkFeatureAccess(featureType)

      if (!hasAccess) {
        this.emitAccessDenied(featureType, 'subscription_required')
        return false
      }

      const hasUsageRemaining = await this.checkUsageLimit(featureType)

      if (!hasUsageRemaining) {
        this.emitAccessDenied(featureType, 'usage_limit_exceeded')
        return false
      }

      return true
    } catch (error) {
      logger.error('FeatureAccessController', 'Failed to check feature access', error)
      return false
    }
  }

  // Check usage limits
  async checkUsageLimit(featureType: string): Promise&lt;boolean&gt; {
    const subscription = paymentController.getUserSubscription()
    const planType = this.getPlanType(subscription)

    const limit = this.featureLimits[planType]?.[featureType]

    // Unlimited access
    if (limit === -1) return true

    // No access
    if (limit === 0) return false

    // Check current usage
    const currentUsage = await this.getCurrentUsage(featureType)
    return currentUsage &lt; limit
  }

  // Get current usage for a feature
  private async getCurrentUsage(featureType: string): Promise&lt;number&gt; {
    // Implementation would query the database for current month usage
    // This is a simplified version
    return 0
  }

  // Get plan type from subscription
  private getPlanType(subscription: any): string {
    if (!subscription || subscription.status !== 'active') {
      return 'free'
    }

    // Extract plan type from subscription data
    // This would be based on your actual plan structure
    return 'basic'
  }

  // Emit access denied event
  private emitAccessDenied(featureType: string, reason: string): void {
    paymentController.emit('access:denied', { featureType, reason })
  }

  // Get feature limits for current user
  async getFeatureLimits(): Promise&lt;Record&lt;string, number&gt;&gt; {
    const subscription = paymentController.getUserSubscription()
    const planType = this.getPlanType(subscription)
    return this.featureLimits[planType] || this.featureLimits.free
  }
}

export const featureAccessController = new FeatureAccessController()</pre
            >
          </div>

          <div class="validation-box">
            <h4>‚úÖ Validation Steps:</h4>
            <ul>
              <li>Test payment controller initialization and event handling</li>
              <li>Verify subscription creation and cancellation workflows</li>
              <li>Check feature access control logic with different plan types</li>
              <li>Test usage tracking and limit enforcement</li>
              <li>Confirm error handling and logging work correctly</li>
            </ul>
          </div>

          <div class="next-steps">
            <h4>üöÄ Next Steps:</h4>
            <p>Proceed to Prompt 8 for Security & Testing implementation.</p>
          </div>
        </section>

        <section id="prompt8" class="prompt-section">
          <div class="prompt-header">
            <h2>Prompt 8: Security & Testing Implementation</h2>
            <div class="objective">
              Implement comprehensive security measures, PCI compliance, and extensive testing
              coverage for the payment system.
            </div>
          </div>

          <h3>Instructions for AI Assistant</h3>

          <h4>Step 1: Create Security Middleware</h4>
          <p>
            1. Create a new file <code>src/middleware/paymentSecurity.ts</code><br />
            2. Implement payment security middleware:
          </p>
          <div class="code-block">
            <pre>
import { NextApiRequest, NextApiResponse } from 'next'
import rateLimit from 'express-rate-limit'
import { logger } from '@/utils/logger'
import crypto from 'crypto'

// Rate limiting for payment endpoints
export const paymentRateLimit = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 10, // limit each IP to 10 requests per windowMs
  message: 'Too many payment requests, please try again later',
  standardHeaders: true,
  legacyHeaders: false,
  handler: (req, res) => {
    logger.warn('PaymentSecurity', `Rate limit exceeded for IP: ${req.ip}`)
    res.status(429).json({ error: 'Rate limit exceeded' })
  }
})

// Webhook signature validation
export function validateWebhookSignature(
  payload: string,
  signature: string,
  secret: string
): boolean {
  try {
    const expectedSignature = crypto
      .createHmac('sha256', secret)
      .update(payload, 'utf8')
      .digest('hex')

    return crypto.timingSafeEqual(
      Buffer.from(signature, 'hex'),
      Buffer.from(expectedSignature, 'hex')
    )
  } catch (error) {
    logger.error('PaymentSecurity', 'Webhook signature validation failed', error)
    return false
  }
}

// Payment data sanitization
export function sanitizePaymentData(data: any): any {
  const sensitiveFields = [
    'card_number',
    'cvv',
    'ssn',
    'bank_account',
    'routing_number'
  ]

  const sanitized = { ...data }

  sensitiveFields.forEach(field => {
    if (sanitized[field]) {
      delete sanitized[field]
    }
  })

  return sanitized
}

// CSRF protection for payment forms
export function validateCSRFToken(req: NextApiRequest): boolean {
  const token = req.headers['x-csrf-token'] as string
  const sessionToken = req.session?.csrfToken

  if (!token || !sessionToken) {
    return false
  }

  return crypto.timingSafeEqual(
    Buffer.from(token),
    Buffer.from(sessionToken)
  )
}

// IP whitelist validation for webhooks
export function validateWebhookIP(req: NextApiRequest): boolean {
  const allowedIPs = [
    '54.187.174.169',
    '54.187.205.235',
    '54.187.216.72',
    // Add other Stripe webhook IPs
  ]

  const clientIP = req.headers['x-forwarded-for'] || req.connection.remoteAddress

  if (!clientIP) {
    return false
  }

  return allowedIPs.includes(clientIP.toString())
}</pre
            >
          </div>

          <h4>Step 2: Create Payment Tests</h4>
          <p>
            1. Create a new file <code>src/__tests__/payments/paymentController.test.ts</code><br />
            2. Implement comprehensive payment controller tests:
          </p>
          <div class="code-block">
            <pre>
import { PaymentController } from '@/controller/paymentController'
import { userPaymentService } from '@/model/userPaymentService'
import { stripeService } from '@/model/stripeService'

// Mock dependencies
jest.mock('@/model/userPaymentService')
jest.mock('@/model/stripeService')

describe('PaymentController', () => {
  let paymentController: PaymentController
  const mockUser = {
    id: 'user-123',
    email: 'test@example.com',
    name: 'Test User'
  }

  beforeEach(() => {
    paymentController = new PaymentController()
    jest.clearAllMocks()
  })

  describe('initialization', () => {
    it('should initialize payment system successfully', async () => {
      const mockPlans = [
        {
          id: 'plan-1',
          name: 'Basic',
          priceCents: 999,
          interval: 'month'
        }
      ]

      ;(userPaymentService.getSubscriptionPlans as jest.Mock).mockResolvedValue(mockPlans)

      await paymentController.initializePaymentSystem()

      expect(userPaymentService.getSubscriptionPlans).toHaveBeenCalled()
      expect(paymentController.getSubscriptionPlans()).toEqual(mockPlans)
    })

    it('should handle initialization errors', async () => {
      const error = new Error('Failed to load plans')
      ;(userPaymentService.getSubscriptionPlans as jest.Mock).mockRejectedValue(error)

      const errorSpy = jest.fn()
      paymentController.on('payment:error', errorSpy)

      await expect(paymentController.initializePaymentSystem()).rejects.toThrow(error)
      expect(errorSpy).toHaveBeenCalledWith(error)
    })
  })

  describe('subscription management', () => {
    beforeEach(async () => {
      const mockPlans = [
        {
          id: 'plan-1',
          stripePriceId: 'price_123',
          name: 'Basic',
          priceCents: 999,
          interval: 'month'
        }
      ]
      ;(userPaymentService.getSubscriptionPlans as jest.Mock).mockResolvedValue(mockPlans)
      await paymentController.initializePaymentSystem()
      await paymentController.setCurrentUser(mockUser)
    })

    it('should create subscription successfully', async () => {
      const mockSubscription = {
        id: 'sub_123',
        customer: 'cus_123',
        status: 'active'
      }

      ;(userPaymentService.ensureStripeCustomer as jest.Mock).mockResolvedValue('cus_123')
      ;(stripeService.createSubscription as jest.Mock).mockResolvedValue(mockSubscription)
      ;(userPaymentService.getUserSubscription as jest.Mock).mockResolvedValue(null)

      const result = await paymentController.createSubscription('plan-1')

      expect(userPaymentService.ensureStripeCustomer).toHaveBeenCalledWith(
        mockUser.id,
        mockUser.email,
        mockUser.name
      )
      expect(stripeService.createSubscription).toHaveBeenCalledWith(
        'cus_123',
        'price_123',
        { userId: mockUser.id }
      )
      expect(result).toEqual(mockSubscription)
    })

    it('should handle subscription creation errors', async () => {
      const error = new Error('Payment failed')
      ;(userPaymentService.ensureStripeCustomer as jest.Mock).mockRejectedValue(error)

      const errorSpy = jest.fn()
      paymentController.on('payment:error', errorSpy)

      await expect(paymentController.createSubscription('plan-1')).rejects.toThrow(error)
      expect(errorSpy).toHaveBeenCalledWith(error)
      expect(paymentController.getPaymentStatus()).toBe('error')
    })
  })

  describe('feature access', () => {
    beforeEach(async () => {
      await paymentController.setCurrentUser(mockUser)
    })

    it('should check feature access correctly', async () => {
      ;(userPaymentService.checkFeatureAccess as jest.Mock).mockResolvedValue(true)

      const hasAccess = await paymentController.checkFeatureAccess('advanced_search')

      expect(userPaymentService.checkFeatureAccess).toHaveBeenCalledWith(
        mockUser.id,
        'advanced_search'
      )
      expect(hasAccess).toBe(true)
    })

    it('should record feature usage', async () => {
      const metadata = { searchQuery: 'test' }
      ;(userPaymentService.recordFeatureUsage as jest.Mock).mockResolvedValue(undefined)

      const usageSpy = jest.fn()
      paymentController.on('usage:recorded', usageSpy)

      await paymentController.recordFeatureUsage('advanced_search', metadata)

      expect(userPaymentService.recordFeatureUsage).toHaveBeenCalledWith(
        mockUser.id,
        'advanced_search',
        metadata
      )
      expect(usageSpy).toHaveBeenCalledWith({
        featureType: 'advanced_search',
        metadata
      })
    })
  })
})</pre
            >
          </div>

          <h4>Step 3: Create Integration Tests</h4>
          <p>
            1. Create a new file <code>src/__tests__/integration/payment-flow.test.ts</code><br />
            2. Implement end-to-end payment flow tests:
          </p>
          <div class="code-block">
            <pre>
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import { PaymentForm } from '@/view/components/payments/PaymentForm'
import { StripeProvider } from '@/view/components/payments/StripeProvider'

// Mock Stripe
jest.mock('@stripe/react-stripe-js', () => ({
  Elements: ({ children }: any) => children,
  PaymentElement: () => &lt;div data-testid="payment-element" /&gt;,
  useStripe: () => ({
    confirmPayment: jest.fn().mockResolvedValue({
      paymentIntent: { status: 'succeeded', id: 'pi_123' }
    })
  }),
  useElements: () => ({
    submit: jest.fn().mockResolvedValue({ error: null })
  })
}))

describe('Payment Flow Integration', () => {
  const defaultProps = {
    amount: 999,
    currency: 'usd',
    description: 'Test payment'
  }

  it('should complete payment flow successfully', async () => {
    const onSuccess = jest.fn()
    const onError = jest.fn()

    render(
      &lt;StripeProvider&gt;
        &lt;PaymentForm
          {...defaultProps}
          onSuccess={onSuccess}
          onError={onError}
        /&gt;
      &lt;/StripeProvider&gt;
    )

    // Check payment details are displayed
    expect(screen.getByText('Test payment')).toBeInTheDocument()
    expect(screen.getByText('$9.99')).toBeInTheDocument()

    // Check payment element is rendered
    expect(screen.getByTestId('payment-element')).toBeInTheDocument()

    // Submit payment
    const submitButton = screen.getByRole('button', { name: /pay \$9\.99/i })
    fireEvent.click(submitButton)

    // Wait for success callback
    await waitFor(() => {
      expect(onSuccess).toHaveBeenCalledWith({
        status: 'succeeded',
        id: 'pi_123'
      })
    })

    expect(onError).not.toHaveBeenCalled()
  })

  it('should handle payment errors gracefully', async () => {
    // Mock payment failure
    jest.mocked(require('@stripe/react-stripe-js').useStripe).mockReturnValue({
      confirmPayment: jest.fn().mockResolvedValue({
        error: { message: 'Your card was declined.' }
      })
    })

    const onSuccess = jest.fn()
    const onError = jest.fn()

    render(
      &lt;StripeProvider&gt;
        &lt;PaymentForm
          {...defaultProps}
          onSuccess={onSuccess}
          onError={onError}
        /&gt;
      &lt;/StripeProvider&gt;
    )

    const submitButton = screen.getByRole('button', { name: /pay \$9\.99/i })
    fireEvent.click(submitButton)

    await waitFor(() => {
      expect(screen.getByText('Your card was declined.')).toBeInTheDocument()
    })

    expect(onError).toHaveBeenCalledWith('Your card was declined.')
    expect(onSuccess).not.toHaveBeenCalled()
  })
})</pre
            >
          </div>

          <div class="validation-box">
            <h4>‚úÖ Validation Steps:</h4>
            <ul>
              <li>Run all payment-related unit tests and ensure 100% pass rate</li>
              <li>Execute integration tests for complete payment flows</li>
              <li>Test security middleware with various attack scenarios</li>
              <li>Verify rate limiting and CSRF protection work correctly</li>
              <li>Check webhook signature validation with test data</li>
              <li>Perform security audit with tools like npm audit</li>
            </ul>
          </div>

          <div class="next-steps">
            <h4>üöÄ Next Steps:</h4>
            <p>Proceed to Prompt 9 for Final Integration and documentation updates.</p>
          </div>
        </section>

        <section id="prompt9" class="prompt-section">
          <div class="prompt-header">
            <h2>Prompt 9: Final Integration and Documentation</h2>
            <div class="objective">
              Complete the payment system integration, update all documentation, and ensure
              production readiness with comprehensive deployment guides.
            </div>
          </div>

          <h3>Instructions for AI Assistant</h3>

          <h4>Step 1: Update Main Application Integration</h4>
          <p>
            1. Open <code>src/pages/_app.tsx</code><br />
            2. Add Stripe provider to the application root:
          </p>
          <div class="code-block">
            <pre>
import { AppProps } from 'next/app'
import { StripeProvider } from '@/view/components/payments/StripeProvider'
import { paymentController } from '@/controller/paymentController'
import { useEffect } from 'react'

function MyApp({ Component, pageProps }: AppProps) {
  useEffect(() => {
    // Initialize payment system on app start
    paymentController.initializePaymentSystem()
  }, [])

  return (
    &lt;StripeProvider&gt;
      &lt;Component {...pageProps} /&gt;
    &lt;/StripeProvider&gt;
  )
}

export default MyApp</pre
            >
          </div>

          <h4>Step 2: Create Payment Pages</h4>
          <p>
            1. Create <code>src/pages/pricing.tsx</code> for subscription plans:<br />
            2. Create <code>src/pages/payment/success.tsx</code> for payment success:<br />
            3. Create <code>src/pages/payment/cancel.tsx</code> for payment cancellation:
          </p>
          <div class="code-block">
            <pre>
// src/pages/pricing.tsx
import { useState, useEffect } from 'react'
import { SubscriptionPlans } from '@/view/components/payments/SubscriptionPlans'
import { paymentController } from '@/controller/paymentController'
import { SubscriptionPlan } from '@/model/types/payment'

export default function PricingPage() {
  const [plans, setPlans] = useState&lt;SubscriptionPlan[]&gt;([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    loadPlans()
  }, [])

  const loadPlans = async () => {
    try {
      const subscriptionPlans = await paymentController.loadSubscriptionPlans()
      setPlans(subscriptionPlans)
    } catch (error) {
      console.error('Failed to load plans:', error)
    } finally {
      setLoading(false)
    }
  }

  const handleSelectPlan = async (plan: SubscriptionPlan) => {
    try {
      await paymentController.createSubscription(plan.id)
      // Redirect to success page or show success message
    } catch (error) {
      console.error('Failed to create subscription:', error)
    }
  }

  if (loading) {
    return &lt;div&gt;Loading plans...&lt;/div&gt;
  }

  return (
    &lt;div className="container mx-auto px-4 py-8"&gt;
      &lt;h1 className="text-3xl font-bold text-center mb-8"&gt;Choose Your Plan&lt;/h1&gt;
      &lt;SubscriptionPlans
        plans={plans}
        onSelectPlan={handleSelectPlan}
      /&gt;
    &lt;/div&gt;
  )
}</pre
            >
          </div>

          <h4>Step 3: Update Environment Configuration</h4>
          <p>
            1. Create production environment file <code>config/production.env</code><br />
            2. Add all required Stripe configuration with live keys:<br />
            3. Update <code>next.config.js</code> for security headers:
          </p>
          <div class="code-block">
            <pre>
// next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,

  async headers() {
    return [
      {
        source: '/api/webhooks/:path*',
        headers: [
          {
            key: 'Access-Control-Allow-Origin',
            value: 'https://api.stripe.com'
          },
          {
            key: 'Access-Control-Allow-Methods',
            value: 'POST'
          },
          {
            key: 'Access-Control-Allow-Headers',
            value: 'stripe-signature, content-type'
          }
        ]
      },
      {
        source: '/api/payments/:path*',
        headers: [
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff'
          },
          {
            key: 'X-Frame-Options',
            value: 'DENY'
          },
          {
            key: 'X-XSS-Protection',
            value: '1; mode=block'
          }
        ]
      }
    ]
  },

  env: {
    STRIPE_PUBLISHABLE_KEY: process.env.STRIPE_PUBLISHABLE_KEY,
  }
}

module.exports = nextConfig</pre
            >
          </div>

          <h4>Step 4: Update Documentation</h4>
          <p>
            1. Update <code>README.md</code> with payment system information:<br />
            2. Update <code>CHANGELOG.md</code> with new features:<br />
            3. Create <code>docs/PAYMENT_SETUP.md</code> deployment guide:
          </p>
          <div class="code-block">
            <pre>
# Payment System Setup Guide

## Stripe Configuration

### 1. Create Stripe Account
- Sign up at https://stripe.com
- Complete account verification
- Enable payment methods for your region

### 2. Get API Keys
- Navigate to Developers > API keys
- Copy Publishable key and Secret key
- Create webhook endpoint for your domain

### 3. Environment Variables
```bash
STRIPE_PUBLISHABLE_KEY=pk_live_...
STRIPE_SECRET_KEY=sk_live_...
STRIPE_WEBHOOK_SECRET=whsec_...
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=${STRIPE_PUBLISHABLE_KEY}
PAYMENT_SUCCESS_URL=https://yourdomain.com/payment/success
PAYMENT_CANCEL_URL=https://yourdomain.com/payment/cancel
```

### 4. Webhook Configuration
- URL: https://yourdomain.com/api/webhooks/stripe
- Events to send:
  - customer.subscription.created
  - customer.subscription.updated
  - customer.subscription.deleted
  - payment_intent.succeeded
  - payment_intent.payment_failed
  - invoice.payment_succeeded

### 5. Database Migration
Run the payment system migration:
```bash
npm run db:migrate
```

### 6. Testing
Use Stripe test cards for development:
- Success: 4242 4242 4242 4242
- Decline: 4000 0000 0000 0002
- 3D Secure: 4000 0025 0000 3155</pre
            >
          </div>

          <h4>Step 5: Update Package.json Scripts</h4>
          <p>
            1. Open <code>package.json</code><br />
            2. Add payment-related scripts:
          </p>
          <div class="code-block">
            <pre>
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "test": "jest",
    "test:payments": "jest --testPathPattern=payments",
    "test:integration": "jest --testPathPattern=integration",
    "db:migrate": "node database/scripts/migrate.js",
    "stripe:listen": "stripe listen --forward-to localhost:3000/api/webhooks/stripe",
    "stripe:fixtures": "stripe fixtures fixtures/stripe_fixtures.json"
  }
}</pre
            >
          </div>

          <div class="validation-box">
            <h4>‚úÖ Validation Steps:</h4>
            <ul>
              <li>Test complete payment flow from plan selection to confirmation</li>
              <li>Verify webhook processing with Stripe CLI</li>
              <li>Check all environment configurations are properly set</li>
              <li>Confirm documentation is complete and accurate</li>
              <li>Test production build and deployment readiness</li>
              <li>Verify all security headers and CORS settings</li>
            </ul>
          </div>

          <div class="next-steps">
            <h4>üöÄ Next Steps:</h4>
            <p>Proceed to Prompt 10 for User Management integration.</p>
          </div>
        </section>

        <section id="prompt10" class="prompt-section">
          <div class="prompt-header">
            <h2>Prompt 10: User Management Integration</h2>
            <div class="objective">
              Integrate payment system with user management, implement user onboarding flows, and
              create comprehensive payment profile management.
            </div>
          </div>

          <h3>Instructions for AI Assistant</h3>

          <h4>Step 1: Extend User Model for Payments</h4>
          <p>
            1. Open <code>src/model/types/user.ts</code><br />
            2. Extend user interface to include payment information:
          </p>
          <div class="code-block">
            <pre>
// Add to existing user interface
export interface User {
  id: string
  email: string
  name: string
  // ... existing fields

  // Payment-related fields
  stripeCustomerId?: string
  subscriptionStatus: 'free' | 'active' | 'past_due' | 'canceled'
  subscriptionPlan?: string
  subscriptionEndsAt?: Date
  paymentMethodLast4?: string
  paymentMethodBrand?: string
  billingAddress?: BillingAddress
  usageQuotas: UsageQuotas
  createdAt: Date
  updatedAt: Date
}

export interface BillingAddress {
  line1: string
  line2?: string
  city: string
  state: string
  postalCode: string
  country: string
}

export interface UsageQuotas {
  scrapingRequests: {
    used: number
    limit: number
    resetDate: Date
  }
  exports: {
    used: number
    limit: number
    resetDate: Date
  }
  advancedSearches: {
    used: number
    limit: number
    resetDate: Date
  }
  apiCalls: {
    used: number
    limit: number
    resetDate: Date
  }
}</pre
            >
          </div>

          <h4>Step 2: Create User Onboarding Service</h4>
          <p>
            1. Create <code>src/model/userOnboardingService.ts</code><br />
            2. Implement comprehensive user onboarding with payment setup:
          </p>
          <div class="code-block">
            <pre>
import { userPaymentService } from './userPaymentService'
import { paymentController } from '@/controller/paymentController'
import { logger } from '@/utils/logger'
import { User } from './types/user'

export class UserOnboardingService {
  // Complete user onboarding process
  async completeOnboarding(
    userId: string,
    userData: Partial&lt;User&gt;,
    selectedPlanId?: string
  ): Promise&lt;User&gt; {
    try {
      logger.info('UserOnboarding', `Starting onboarding for user: ${userId}`)

      // 1. Create or update user profile
      const user = await this.createUserProfile(userId, userData)

      // 2. Initialize payment profile
      await this.initializePaymentProfile(user)

      // 3. Set up subscription if plan selected
      if (selectedPlanId) {
        await this.setupInitialSubscription(user, selectedPlanId)
      }

      // 4. Initialize usage quotas
      await this.initializeUsageQuotas(user)

      // 5. Send welcome email
      await this.sendWelcomeEmail(user)

      logger.info('UserOnboarding', `Onboarding completed for user: ${userId}`)
      return user
    } catch (error) {
      logger.error('UserOnboarding', 'Onboarding failed', error)
      throw error
    }
  }

  // Create user profile
  private async createUserProfile(userId: string, userData: Partial&lt;User&gt;): Promise&lt;User&gt; {
    const user: User = {
      id: userId,
      email: userData.email!,
      name: userData.name!,
      subscriptionStatus: 'free',
      usageQuotas: this.getDefaultQuotas(),
      createdAt: new Date(),
      updatedAt: new Date(),
      ...userData
    }

    // Save to database
    await this.saveUserProfile(user)
    return user
  }

  // Initialize payment profile
  private async initializePaymentProfile(user: User): Promise&lt;void&gt; {
    try {
      // Create Stripe customer
      const stripeCustomerId = await userPaymentService.ensureStripeCustomer(
        user.id,
        user.email,
        user.name
      )

      // Update user with Stripe customer ID
      await this.updateUserProfile(user.id, { stripeCustomerId })
    } catch (error) {
      logger.error('UserOnboarding', 'Failed to initialize payment profile', error)
      throw error
    }
  }

  // Setup initial subscription
  private async setupInitialSubscription(user: User, planId: string): Promise&lt;void&gt; {
    try {
      await paymentController.setCurrentUser(user)
      await paymentController.createSubscription(planId)

      // Update user subscription status
      await this.updateUserProfile(user.id, {
        subscriptionStatus: 'active',
        subscriptionPlan: planId
      })
    } catch (error) {
      logger.error('UserOnboarding', 'Failed to setup subscription', error)
      // Don't throw - allow user to complete onboarding without subscription
    }
  }

  // Initialize usage quotas based on plan
  private initializeUsageQuotas(user: User): UsageQuotas {
    const resetDate = new Date()
    resetDate.setMonth(resetDate.getMonth() + 1)

    const quotas = this.getQuotasForPlan(user.subscriptionPlan || 'free')

    return {
      scrapingRequests: { used: 0, limit: quotas.scrapingRequests, resetDate },
      exports: { used: 0, limit: quotas.exports, resetDate },
      advancedSearches: { used: 0, limit: quotas.advancedSearches, resetDate },
      apiCalls: { used: 0, limit: quotas.apiCalls, resetDate }
    }
  }

  // Get default quotas for free plan
  private getDefaultQuotas(): UsageQuotas {
    return this.initializeUsageQuotas({ subscriptionPlan: 'free' } as User)
  }

  // Get quotas based on plan
  private getQuotasForPlan(planType: string): Record&lt;string, number&gt; {
    const quotaMap: Record&lt;string, Record&lt;string, number&gt;&gt; = {
      free: { scrapingRequests: 10, exports: 5, advancedSearches: 0, apiCalls: 0 },
      basic: { scrapingRequests: 100, exports: 50, advancedSearches: 10, apiCalls: 0 },
      pro: { scrapingRequests: 1000, exports: 500, advancedSearches: 100, apiCalls: 50 },
      enterprise: { scrapingRequests: -1, exports: -1, advancedSearches: -1, apiCalls: -1 }
    }

    return quotaMap[planType] || quotaMap.free
  }

  // Send welcome email
  private async sendWelcomeEmail(user: User): Promise&lt;void&gt; {
    // Implementation would integrate with email service
    logger.info('UserOnboarding', `Welcome email sent to: ${user.email}`)
  }

  // Helper methods for database operations
  private async saveUserProfile(user: User): Promise&lt;void&gt; {
    // Implementation would save to database
  }

  private async updateUserProfile(userId: string, updates: Partial&lt;User&gt;): Promise&lt;void&gt; {
    // Implementation would update database
  }
}

export const userOnboardingService = new UserOnboardingService()</pre
            >
          </div>

          <h4>Step 3: Create User Dashboard Component</h4>
          <p>
            1. Create <code>src/view/components/user/UserDashboard.tsx</code><br />
            2. Implement comprehensive user dashboard with payment management:
          </p>
          <div class="code-block">
            <pre>
import React, { useState, useEffect } from 'react'
import { User } from '@/model/types/user'
import { paymentController } from '@/controller/paymentController'
import { Card } from '@/view/components/ui/Card'
import { Button } from '@/view/components/ui/Button'
import { ProgressBar } from '@/view/components/ui/ProgressBar'
import { Badge } from '@/view/components/ui/Badge'

interface UserDashboardProps {
  user: User
  onUpdateUser: (user: User) =&gt; void
}

export const UserDashboard: React.FC&lt;UserDashboardProps&gt; = ({
  user,
  onUpdateUser
}) =&gt; {
  const [subscription, setSubscription] = useState(null)
  const [loading, setLoading] = useState(false)

  useEffect(() => {
    loadUserData()
  }, [user.id])

  const loadUserData = async () =&gt; {
    try {
      await paymentController.setCurrentUser(user)
      const userSubscription = paymentController.getUserSubscription()
      setSubscription(userSubscription)
    } catch (error) {
      console.error('Failed to load user data:', error)
    }
  }

  const handleCancelSubscription = async () =&gt; {
    if (!confirm('Are you sure you want to cancel your subscription?')) return

    setLoading(true)
    try {
      await paymentController.cancelSubscription()
      await loadUserData()
      onUpdateUser({ ...user, subscriptionStatus: 'canceled' })
    } catch (error) {
      console.error('Failed to cancel subscription:', error)
    } finally {
      setLoading(false)
    }
  }

  const getUsagePercentage = (used: number, limit: number) =&gt; {
    if (limit === -1) return 0 // Unlimited
    return Math.min((used / limit) * 100, 100)
  }

  const formatUsage = (used: number, limit: number) =&gt; {
    if (limit === -1) return `${used} / Unlimited`
    return `${used} / ${limit}`
  }

  return (
    &lt;div className="space-y-6"&gt;
      {/* Account Overview */}
      &lt;Card className="p-6"&gt;
        &lt;h2 className="text-2xl font-bold mb-4"&gt;Account Overview&lt;/h2&gt;
        &lt;div className="grid grid-cols-1 md:grid-cols-2 gap-4"&gt;
          &lt;div&gt;
            &lt;p className="text-gray-600"&gt;Email&lt;/p&gt;
            &lt;p className="font-semibold"&gt;{user.email}&lt;/p&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;p className="text-gray-600"&gt;Subscription Status&lt;/p&gt;
            &lt;Badge variant={user.subscriptionStatus === 'active' ? 'success' : 'secondary'}&gt;
              {user.subscriptionStatus}
            &lt;/Badge&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;p className="text-gray-600"&gt;Plan&lt;/p&gt;
            &lt;p className="font-semibold"&gt;{user.subscriptionPlan || 'Free'}&lt;/p&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;p className="text-gray-600"&gt;Member Since&lt;/p&gt;
            &lt;p className="font-semibold"&gt;
              {new Date(user.createdAt).toLocaleDateString()}
            &lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/Card&gt;

      {/* Usage Quotas */}
      &lt;Card className="p-6"&gt;
        &lt;h3 className="text-xl font-bold mb-4"&gt;Usage This Month&lt;/h3&gt;
        &lt;div className="space-y-4"&gt;
          {Object.entries(user.usageQuotas).map(([key, quota]) =&gt; (
            &lt;div key={key}&gt;
              &lt;div className="flex justify-between mb-2"&gt;
                &lt;span className="capitalize"&gt;{key.replace(/([A-Z])/g, ' $1')}&lt;/span&gt;
                &lt;span className="text-sm text-gray-600"&gt;
                  {formatUsage(quota.used, quota.limit)}
                &lt;/span&gt;
              &lt;/div&gt;
              &lt;ProgressBar
                value={getUsagePercentage(quota.used, quota.limit)}
                className="h-2"
              /&gt;
            &lt;/div&gt;
          ))}
        &lt;/div&gt;
      &lt;/Card&gt;

      {/* Subscription Management */}
      {user.subscriptionStatus === 'active' && (
        &lt;Card className="p-6"&gt;
          &lt;h3 className="text-xl font-bold mb-4"&gt;Subscription Management&lt;/h3&gt;
          &lt;div className="space-y-4"&gt;
            &lt;div&gt;
              &lt;p className="text-gray-600"&gt;Current Plan&lt;/p&gt;
              &lt;p className="font-semibold text-lg"&gt;{user.subscriptionPlan}&lt;/p&gt;
            &lt;/div&gt;
            {user.subscriptionEndsAt && (
              &lt;div&gt;
                &lt;p className="text-gray-600"&gt;Next Billing Date&lt;/p&gt;
                &lt;p className="font-semibold"&gt;
                  {new Date(user.subscriptionEndsAt).toLocaleDateString()}
                &lt;/p&gt;
              &lt;/div&gt;
            )}
            &lt;div className="flex space-x-4"&gt;
              &lt;Button variant="outline"&gt;
                Change Plan
              &lt;/Button&gt;
              &lt;Button
                variant="destructive"
                onClick={handleCancelSubscription}
                disabled={loading}
              &gt;
                {loading ? 'Canceling...' : 'Cancel Subscription'}
              &lt;/Button&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/Card&gt;
      )}

      {/* Upgrade Prompt for Free Users */}
      {user.subscriptionStatus === 'free' && (
        &lt;Card className="p-6 bg-gradient-to-r from-blue-50 to-purple-50"&gt;
          &lt;h3 className="text-xl font-bold mb-2"&gt;Upgrade Your Account&lt;/h3&gt;
          &lt;p className="text-gray-600 mb-4"&gt;
            Get access to advanced features and higher usage limits.
          &lt;/p&gt;
          &lt;Button&gt;View Plans&lt;/Button&gt;
        &lt;/Card&gt;
      )}
    &lt;/div&gt;
  )
}</pre
            >
          </div>

          <div class="validation-box">
            <h4>‚úÖ Validation Steps:</h4>
            <ul>
              <li>Test complete user onboarding flow with and without subscription</li>
              <li>Verify user dashboard displays correct payment and usage information</li>
              <li>Check subscription management features work correctly</li>
              <li>Test usage quota tracking and display</li>
              <li>Confirm user profile updates sync with payment system</li>
            </ul>
          </div>

          <div class="next-steps">
            <h4>üöÄ Next Steps:</h4>
            <p>Proceed to Prompt 11 for Analytics and Business Intelligence implementation.</p>
          </div>
        </section>

        <section id="prompt11" class="prompt-section">
          <div class="prompt-header">
            <h2>Prompt 11: Analytics and Business Intelligence</h2>
            <div class="objective">
              Implement comprehensive analytics system for revenue tracking, user behavior analysis,
              and business intelligence reporting with real-time dashboards.
            </div>
          </div>

          <h3>Instructions for AI Assistant</h3>

          <h4>Step 1: Create Analytics Service</h4>
          <p>
            1. Create <code>src/model/analyticsService.ts</code><br />
            2. Implement comprehensive analytics data collection and processing:
          </p>
          <div class="code-block">
            <pre>
import { storage } from './storage'
import { logger } from '@/utils/logger'

export interface AnalyticsEvent {
  id: string
  userId?: string
  eventType: string
  eventData: Record&lt;string, any&gt;
  timestamp: Date
  sessionId?: string
  userAgent?: string
  ipAddress?: string
}

export interface RevenueMetrics {
  totalRevenue: number
  monthlyRecurringRevenue: number
  averageRevenuePerUser: number
  churnRate: number
  lifetimeValue: number
  conversionRate: number
}

export interface UserMetrics {
  totalUsers: number
  activeUsers: number
  newUsers: number
  retentionRate: number
  engagementScore: number
}

export class AnalyticsService {
  // Track user events
  async trackEvent(
    eventType: string,
    eventData: Record&lt;string, any&gt;,
    userId?: string,
    sessionId?: string
  ): Promise&lt;void&gt; {
    try {
      const event: AnalyticsEvent = {
        id: this.generateEventId(),
        userId,
        eventType,
        eventData,
        timestamp: new Date(),
        sessionId,
        userAgent: typeof window !== 'undefined' ? navigator.userAgent : undefined
      }

      await this.storeEvent(event)
      await this.processEventInRealTime(event)

      logger.info('Analytics', `Event tracked: ${eventType}`, { userId, eventData })
    } catch (error) {
      logger.error('Analytics', 'Failed to track event', error)
    }
  }

  // Get revenue metrics
  async getRevenueMetrics(startDate: Date, endDate: Date): Promise&lt;RevenueMetrics&gt; {
    try {
      const transactions = await this.getTransactionsInPeriod(startDate, endDate)
      const subscriptions = await this.getActiveSubscriptions()

      const totalRevenue = transactions.reduce((sum, t) =&gt; sum + t.amountCents, 0) / 100
      const monthlyRecurringRevenue = this.calculateMRR(subscriptions)
      const averageRevenuePerUser = this.calculateARPU(totalRevenue, subscriptions.length)
      const churnRate = await this.calculateChurnRate(startDate, endDate)
      const lifetimeValue = this.calculateLTV(averageRevenuePerUser, churnRate)
      const conversionRate = await this.calculateConversionRate(startDate, endDate)

      return {
        totalRevenue,
        monthlyRecurringRevenue,
        averageRevenuePerUser,
        churnRate,
        lifetimeValue,
        conversionRate
      }
    } catch (error) {
      logger.error('Analytics', 'Failed to get revenue metrics', error)
      throw error
    }
  }

  // Get user metrics
  async getUserMetrics(startDate: Date, endDate: Date): Promise&lt;UserMetrics&gt; {
    try {
      const totalUsers = await this.getTotalUsers()
      const activeUsers = await this.getActiveUsers(startDate, endDate)
      const newUsers = await this.getNewUsers(startDate, endDate)
      const retentionRate = await this.calculateRetentionRate(startDate, endDate)
      const engagementScore = await this.calculateEngagementScore(startDate, endDate)

      return {
        totalUsers,
        activeUsers,
        newUsers,
        retentionRate,
        engagementScore
      }
    } catch (error) {
      logger.error('Analytics', 'Failed to get user metrics', error)
      throw error
    }
  }

  // Get feature usage analytics
  async getFeatureUsageAnalytics(startDate: Date, endDate: Date): Promise&lt;any&gt; {
    try {
      const events = await this.getEventsInPeriod(startDate, endDate)

      const featureUsage = events.reduce((acc, event) =&gt; {
        if (event.eventType.startsWith('feature_')) {
          const feature = event.eventType.replace('feature_', '')
          acc[feature] = (acc[feature] || 0) + 1
        }
        return acc
      }, {} as Record&lt;string, number&gt;)

      const topFeatures = Object.entries(featureUsage)
        .sort(([,a], [,b]) =&gt; b - a)
        .slice(0, 10)

      return {
        featureUsage,
        topFeatures,
        totalFeatureUsage: Object.values(featureUsage).reduce((sum, count) =&gt; sum + count, 0)
      }
    } catch (error) {
      logger.error('Analytics', 'Failed to get feature usage analytics', error)
      throw error
    }
  }

  // Calculate Monthly Recurring Revenue
  private calculateMRR(subscriptions: any[]): number {
    return subscriptions.reduce((mrr, sub) =&gt; {
      if (sub.status === 'active') {
        const monthlyAmount = sub.interval === 'year'
          ? sub.priceCents / 12
          : sub.priceCents
        return mrr + (monthlyAmount / 100)
      }
      return mrr
    }, 0)
  }

  // Calculate Average Revenue Per User
  private calculateARPU(totalRevenue: number, userCount: number): number {
    return userCount &gt; 0 ? totalRevenue / userCount : 0
  }

  // Calculate Customer Lifetime Value
  private calculateLTV(arpu: number, churnRate: number): number {
    return churnRate &gt; 0 ? arpu / churnRate : 0
  }

  // Calculate churn rate
  private async calculateChurnRate(startDate: Date, endDate: Date): Promise&lt;number&gt; {
    const startUsers = await this.getActiveUsersAtDate(startDate)
    const churnedUsers = await this.getChurnedUsers(startDate, endDate)

    return startUsers &gt; 0 ? churnedUsers / startUsers : 0
  }

  // Calculate conversion rate
  private async calculateConversionRate(startDate: Date, endDate: Date): Promise&lt;number&gt; {
    const visitors = await this.getUniqueVisitors(startDate, endDate)
    const conversions = await this.getConversions(startDate, endDate)

    return visitors &gt; 0 ? conversions / visitors : 0
  }

  // Helper methods for data retrieval
  private async getTransactionsInPeriod(startDate: Date, endDate: Date): Promise&lt;any[]&gt; {
    // Implementation would query payment transactions
    return []
  }

  private async getActiveSubscriptions(): Promise&lt;any[]&gt; {
    // Implementation would query active subscriptions
    return []
  }

  private async getEventsInPeriod(startDate: Date, endDate: Date): Promise&lt;AnalyticsEvent[]&gt; {
    // Implementation would query analytics events
    return []
  }

  private async storeEvent(event: AnalyticsEvent): Promise&lt;void&gt; {
    // Implementation would store event in database
  }

  private async processEventInRealTime(event: AnalyticsEvent): Promise&lt;void&gt; {
    // Implementation would process event for real-time analytics
  }

  private generateEventId(): string {
    return `evt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }

  // Additional helper methods...
  private async getTotalUsers(): Promise&lt;number&gt; { return 0 }
  private async getActiveUsers(start: Date, end: Date): Promise&lt;number&gt; { return 0 }
  private async getNewUsers(start: Date, end: Date): Promise&lt;number&gt; { return 0 }
  private async calculateRetentionRate(start: Date, end: Date): Promise&lt;number&gt; { return 0 }
  private async calculateEngagementScore(start: Date, end: Date): Promise&lt;number&gt; { return 0 }
  private async getActiveUsersAtDate(date: Date): Promise&lt;number&gt; { return 0 }
  private async getChurnedUsers(start: Date, end: Date): Promise&lt;number&gt; { return 0 }
  private async getUniqueVisitors(start: Date, end: Date): Promise&lt;number&gt; { return 0 }
  private async getConversions(start: Date, end: Date): Promise&lt;number&gt; { return 0 }
}

export const analyticsService = new AnalyticsService()</pre
            >
          </div>

          <h4>Step 2: Create Analytics Dashboard Component</h4>
          <p>
            1. Create <code>src/view/components/analytics/AnalyticsDashboard.tsx</code><br />
            2. Implement comprehensive analytics dashboard:
          </p>
          <div class="code-block">
            <pre>
import React, { useState, useEffect } from 'react'
import { analyticsService, RevenueMetrics, UserMetrics } from '@/model/analyticsService'
import { Card } from '@/view/components/ui/Card'
import { Select } from '@/view/components/ui/Select'
import { LineChart, BarChart, PieChart } from '@/view/components/ui/Charts'

export const AnalyticsDashboard: React.FC = () =&gt; {
  const [timeRange, setTimeRange] = useState('30d')
  const [revenueMetrics, setRevenueMetrics] = useState&lt;RevenueMetrics | null&gt;(null)
  const [userMetrics, setUserMetrics] = useState&lt;UserMetrics | null&gt;(null)
  const [featureUsage, setFeatureUsage] = useState&lt;any&gt;(null)
  const [loading, setLoading] = useState(true)

  useEffect(() =&gt; {
    loadAnalytics()
  }, [timeRange])

  const loadAnalytics = async () =&gt; {
    setLoading(true)
    try {
      const { startDate, endDate } = getDateRange(timeRange)

      const [revenue, users, features] = await Promise.all([
        analyticsService.getRevenueMetrics(startDate, endDate),
        analyticsService.getUserMetrics(startDate, endDate),
        analyticsService.getFeatureUsageAnalytics(startDate, endDate)
      ])

      setRevenueMetrics(revenue)
      setUserMetrics(users)
      setFeatureUsage(features)
    } catch (error) {
      console.error('Failed to load analytics:', error)
    } finally {
      setLoading(false)
    }
  }

  const getDateRange = (range: string) =&gt; {
    const endDate = new Date()
    const startDate = new Date()

    switch (range) {
      case '7d':
        startDate.setDate(endDate.getDate() - 7)
        break
      case '30d':
        startDate.setDate(endDate.getDate() - 30)
        break
      case '90d':
        startDate.setDate(endDate.getDate() - 90)
        break
      case '1y':
        startDate.setFullYear(endDate.getFullYear() - 1)
        break
    }

    return { startDate, endDate }
  }

  const formatCurrency = (amount: number) =&gt; {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD'
    }).format(amount)
  }

  const formatPercentage = (value: number) =&gt; {
    return `${(value * 100).toFixed(1)}%`
  }

  if (loading) {
    return &lt;div className="flex justify-center p-8"&gt;Loading analytics...&lt;/div&gt;
  }

  return (
    &lt;div className="space-y-6"&gt;
      {/* Header */}
      &lt;div className="flex justify-between items-center"&gt;
        &lt;h1 className="text-3xl font-bold"&gt;Analytics Dashboard&lt;/h1&gt;
        &lt;Select
          value={timeRange}
          onValueChange={setTimeRange}
          options={[
            { value: '7d', label: 'Last 7 days' },
            { value: '30d', label: 'Last 30 days' },
            { value: '90d', label: 'Last 90 days' },
            { value: '1y', label: 'Last year' }
          ]}
        /&gt;
      &lt;/div&gt;

      {/* Revenue Metrics */}
      {revenueMetrics && (
        &lt;div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6"&gt;
          &lt;Card className="p-6"&gt;
            &lt;h3 className="text-sm font-medium text-gray-600"&gt;Total Revenue&lt;/h3&gt;
            &lt;p className="text-2xl font-bold text-green-600"&gt;
              {formatCurrency(revenueMetrics.totalRevenue)}
            &lt;/p&gt;
          &lt;/Card&gt;
          &lt;Card className="p-6"&gt;
            &lt;h3 className="text-sm font-medium text-gray-600"&gt;Monthly Recurring Revenue&lt;/h3&gt;
            &lt;p className="text-2xl font-bold text-blue-600"&gt;
              {formatCurrency(revenueMetrics.monthlyRecurringRevenue)}
            &lt;/p&gt;
          &lt;/Card&gt;
          &lt;Card className="p-6"&gt;
            &lt;h3 className="text-sm font-medium text-gray-600"&gt;Average Revenue Per User&lt;/h3&gt;
            &lt;p className="text-2xl font-bold text-purple-600"&gt;
              {formatCurrency(revenueMetrics.averageRevenuePerUser)}
            &lt;/p&gt;
          &lt;/Card&gt;
          &lt;Card className="p-6"&gt;
            &lt;h3 className="text-sm font-medium text-gray-600"&gt;Churn Rate&lt;/h3&gt;
            &lt;p className="text-2xl font-bold text-red-600"&gt;
              {formatPercentage(revenueMetrics.churnRate)}
            &lt;/p&gt;
          &lt;/Card&gt;
        &lt;/div&gt;
      )}

      {/* User Metrics */}
      {userMetrics && (
        &lt;div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6"&gt;
          &lt;Card className="p-6"&gt;
            &lt;h3 className="text-sm font-medium text-gray-600"&gt;Total Users&lt;/h3&gt;
            &lt;p className="text-2xl font-bold"&gt;{userMetrics.totalUsers.toLocaleString()}&lt;/p&gt;
          &lt;/Card&gt;
          &lt;Card className="p-6"&gt;
            &lt;h3 className="text-sm font-medium text-gray-600"&gt;Active Users&lt;/h3&gt;
            &lt;p className="text-2xl font-bold"&gt;{userMetrics.activeUsers.toLocaleString()}&lt;/p&gt;
          &lt;/Card&gt;
          &lt;Card className="p-6"&gt;
            &lt;h3 className="text-sm font-medium text-gray-600"&gt;New Users&lt;/h3&gt;
            &lt;p className="text-2xl font-bold"&gt;{userMetrics.newUsers.toLocaleString()}&lt;/p&gt;
          &lt;/Card&gt;
          &lt;Card className="p-6"&gt;
            &lt;h3 className="text-sm font-medium text-gray-600"&gt;Retention Rate&lt;/h3&gt;
            &lt;p className="text-2xl font-bold"&gt;{formatPercentage(userMetrics.retentionRate)}&lt;/p&gt;
          &lt;/Card&gt;
        &lt;/div&gt;
      )}

      {/* Feature Usage Chart */}
      {featureUsage && (
        &lt;Card className="p-6"&gt;
          &lt;h3 className="text-xl font-bold mb-4"&gt;Feature Usage&lt;/h3&gt;
          &lt;BarChart
            data={featureUsage.topFeatures.map(([feature, count]: [string, number]) =&gt; ({
              name: feature,
              value: count
            }))}
            height={300}
          /&gt;
        &lt;/Card&gt;
      )}
    &lt;/div&gt;
  )
}</pre
            >
          </div>

          <div class="validation-box">
            <h4>‚úÖ Validation Steps:</h4>
            <ul>
              <li>Test analytics event tracking with sample user interactions</li>
              <li>Verify revenue metrics calculations are accurate</li>
              <li>Check user metrics display correctly in dashboard</li>
              <li>Test feature usage analytics and chart rendering</li>
              <li>Confirm real-time analytics processing works</li>
              <li>Validate data export functionality for business reporting</li>
            </ul>
          </div>

          <div class="next-steps">
            <h4>üöÄ Next Steps:</h4>
            <p>Proceed to Prompt 12 for Compliance and Audit Logging implementation.</p>
          </div>
        </section>

        <section id="prompt12" class="prompt-section">
          <div class="prompt-header">
            <h2>Prompt 12: Compliance and Audit Logging</h2>
            <div class="objective">
              Implement comprehensive compliance measures including GDPR, PCI DSS, SOC 2 compliance,
              and detailed audit logging for all payment-related activities.
            </div>
          </div>

          <h3>Instructions for AI Assistant</h3>

          <h4>Step 1: Create Audit Logging Service</h4>
          <p>
            1. Create <code>src/model/auditService.ts</code><br />
            2. Implement comprehensive audit logging system:
          </p>
          <div class="code-block">
            <pre>
import { logger } from '@/utils/logger'
import { storage } from './storage'

export interface AuditLog {
  id: string
  userId?: string
  action: string
  resource: string
  resourceId?: string
  oldValues?: Record&lt;string, any&gt;
  newValues?: Record&lt;string, any&gt;
  ipAddress?: string
  userAgent?: string
  timestamp: Date
  severity: 'low' | 'medium' | 'high' | 'critical'
  category: 'payment' | 'user' | 'security' | 'data' | 'system'
  complianceFlags?: string[]
}

export class AuditService {
  // Log audit events
  async logAuditEvent(
    action: string,
    resource: string,
    options: {
      userId?: string
      resourceId?: string
      oldValues?: Record&lt;string, any&gt;
      newValues?: Record&lt;string, any&gt;
      ipAddress?: string
      userAgent?: string
      severity?: 'low' | 'medium' | 'high' | 'critical'
      category?: 'payment' | 'user' | 'security' | 'data' | 'system'
      complianceFlags?: string[]
    } = {}
  ): Promise&lt;void&gt; {
    try {
      const auditLog: AuditLog = {
        id: this.generateAuditId(),
        userId: options.userId,
        action,
        resource,
        resourceId: options.resourceId,
        oldValues: options.oldValues,
        newValues: options.newValues,
        ipAddress: options.ipAddress,
        userAgent: options.userAgent,
        timestamp: new Date(),
        severity: options.severity || 'medium',
        category: options.category || 'system',
        complianceFlags: options.complianceFlags || []
      }

      await this.storeAuditLog(auditLog)
      await this.processComplianceFlags(auditLog)

      logger.info('Audit', `Audit event logged: ${action}`, {
        resource,
        userId: options.userId,
        severity: auditLog.severity
      })
    } catch (error) {
      logger.error('Audit', 'Failed to log audit event', error)
    }
  }

  // Log payment-specific events
  async logPaymentEvent(
    action: string,
    paymentData: any,
    userId?: string,
    ipAddress?: string
  ): Promise&lt;void&gt; {
    const sanitizedData = this.sanitizePaymentData(paymentData)

    await this.logAuditEvent(action, 'payment', {
      userId,
      resourceId: paymentData.id,
      newValues: sanitizedData,
      ipAddress,
      severity: 'high',
      category: 'payment',
      complianceFlags: ['PCI_DSS', 'SOX']
    })
  }

  // Log user data access (GDPR compliance)
  async logDataAccess(
    userId: string,
    dataType: string,
    accessedBy?: string,
    purpose?: string
  ): Promise&lt;void&gt; {
    await this.logAuditEvent('data_access', 'user_data', {
      userId: accessedBy,
      resourceId: userId,
      newValues: { dataType, purpose },
      severity: 'medium',
      category: 'data',
      complianceFlags: ['GDPR']
    })
  }

  // Log security events
  async logSecurityEvent(
    action: string,
    details: Record&lt;string, any&gt;,
    ipAddress?: string,
    userId?: string
  ): Promise&lt;void&gt; {
    await this.logAuditEvent(action, 'security', {
      userId,
      newValues: details,
      ipAddress,
      severity: 'critical',
      category: 'security',
      complianceFlags: ['SOC2', 'ISO27001']
    })
  }

  // Get audit logs with filtering
  async getAuditLogs(filters: {
    userId?: string
    category?: string
    startDate?: Date
    endDate?: Date
    severity?: string
    limit?: number
    offset?: number
  }): Promise&lt;{ logs: AuditLog[], total: number }&gt; {
    try {
      // Implementation would query audit logs from database
      const logs = await this.queryAuditLogs(filters)
      const total = await this.countAuditLogs(filters)

      return { logs, total }
    } catch (error) {
      logger.error('Audit', 'Failed to get audit logs', error)
      throw error
    }
  }

  // Generate compliance report
  async generateComplianceReport(
    startDate: Date,
    endDate: Date,
    complianceType: 'GDPR' | 'PCI_DSS' | 'SOC2' | 'SOX'
  ): Promise&lt;any&gt; {
    try {
      const logs = await this.getAuditLogs({
        startDate,
        endDate
      })

      const relevantLogs = logs.logs.filter(log =&gt;
        log.complianceFlags?.includes(complianceType)
      )

      const report = {
        complianceType,
        period: { startDate, endDate },
        totalEvents: relevantLogs.length,
        eventsByCategory: this.groupLogsByCategory(relevantLogs),
        eventsBySeverity: this.groupLogsBySeverity(relevantLogs),
        securityIncidents: relevantLogs.filter(log =&gt;
          log.category === 'security' && log.severity === 'critical'
        ),
        dataAccessEvents: relevantLogs.filter(log =&gt;
          log.category === 'data'
        ),
        paymentEvents: relevantLogs.filter(log =&gt;
          log.category === 'payment'
        ),
        generatedAt: new Date()
      }

      await this.storeComplianceReport(report)
      return report
    } catch (error) {
      logger.error('Audit', 'Failed to generate compliance report', error)
      throw error
    }
  }

  // Data retention management (GDPR compliance)
  async manageDataRetention(): Promise&lt;void&gt; {
    try {
      const retentionPeriod = 7 * 365 * 24 * 60 * 60 * 1000 // 7 years in milliseconds
      const cutoffDate = new Date(Date.now() - retentionPeriod)

      const oldLogs = await this.getAuditLogs({
        endDate: cutoffDate
      })

      // Archive old logs before deletion
      await this.archiveAuditLogs(oldLogs.logs)

      // Delete old logs
      await this.deleteAuditLogs(oldLogs.logs.map(log =&gt; log.id))

      logger.info('Audit', `Data retention: Archived and deleted ${oldLogs.logs.length} old audit logs`)
    } catch (error) {
      logger.error('Audit', 'Failed to manage data retention', error)
      throw error
    }
  }

  // Sanitize payment data for logging
  private sanitizePaymentData(data: any): any {
    const sensitiveFields = [
      'card_number',
      'cvv',
      'ssn',
      'bank_account',
      'routing_number',
      'payment_method_details'
    ]

    const sanitized = { ...data }

    sensitiveFields.forEach(field =&gt; {
      if (sanitized[field]) {
        if (field === 'card_number' && typeof sanitized[field] === 'string') {
          // Keep only last 4 digits
          sanitized[field] = `****-****-****-${sanitized[field].slice(-4)}`
        } else {
          sanitized[field] = '[REDACTED]'
        }
      }
    })

    return sanitized
  }

  // Process compliance flags
  private async processComplianceFlags(auditLog: AuditLog): Promise&lt;void&gt; {
    if (auditLog.complianceFlags?.includes('PCI_DSS')) {
      await this.processPCICompliance(auditLog)
    }

    if (auditLog.complianceFlags?.includes('GDPR')) {
      await this.processGDPRCompliance(auditLog)
    }

    if (auditLog.complianceFlags?.includes('SOC2')) {
      await this.processSOC2Compliance(auditLog)
    }
  }

  // Helper methods
  private generateAuditId(): string {
    return `audit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }

  private async storeAuditLog(log: AuditLog): Promise&lt;void&gt; {
    // Implementation would store in secure audit database
  }

  private async queryAuditLogs(filters: any): Promise&lt;AuditLog[]&gt; {
    // Implementation would query database
    return []
  }

  private async countAuditLogs(filters: any): Promise&lt;number&gt; {
    // Implementation would count matching logs
    return 0
  }

  private groupLogsByCategory(logs: AuditLog[]): Record&lt;string, number&gt; {
    return logs.reduce((acc, log) =&gt; {
      acc[log.category] = (acc[log.category] || 0) + 1
      return acc
    }, {} as Record&lt;string, number&gt;)
  }

  private groupLogsBySeverity(logs: AuditLog[]): Record&lt;string, number&gt; {
    return logs.reduce((acc, log) =&gt; {
      acc[log.severity] = (acc[log.severity] || 0) + 1
      return acc
    }, {} as Record&lt;string, number&gt;)
  }

  private async storeComplianceReport(report: any): Promise&lt;void&gt; {
    // Implementation would store compliance report
  }

  private async archiveAuditLogs(logs: AuditLog[]): Promise&lt;void&gt; {
    // Implementation would archive logs to long-term storage
  }

  private async deleteAuditLogs(logIds: string[]): Promise&lt;void&gt; {
    // Implementation would delete logs from active database
  }

  private async processPCICompliance(log: AuditLog): Promise&lt;void&gt; {
    // PCI DSS specific processing
  }

  private async processGDPRCompliance(log: AuditLog): Promise&lt;void&gt; {
    // GDPR specific processing
  }

  private async processSOC2Compliance(log: AuditLog): Promise&lt;void&gt; {
    // SOC 2 specific processing
  }
}

export const auditService = new AuditService()</pre
            >
          </div>

          <h4>Step 2: Create GDPR Compliance Service</h4>
          <p>
            1. Create <code>src/model/gdprService.ts</code><br />
            2. Implement GDPR compliance features:
          </p>
          <div class="code-block">
            <pre>
import { auditService } from './auditService'
import { userPaymentService } from './userPaymentService'
import { logger } from '@/utils/logger'

export interface DataExportRequest {
  id: string
  userId: string
  requestedAt: Date
  completedAt?: Date
  status: 'pending' | 'processing' | 'completed' | 'failed'
  downloadUrl?: string
  expiresAt?: Date
}

export interface DataDeletionRequest {
  id: string
  userId: string
  requestedAt: Date
  scheduledFor: Date
  completedAt?: Date
  status: 'pending' | 'scheduled' | 'completed' | 'failed'
  retentionReason?: string
}

export class GDPRService {
  // Handle data export request (Right to Data Portability)
  async requestDataExport(userId: string, requestedBy: string): Promise&lt;DataExportRequest&gt; {
    try {
      const request: DataExportRequest = {
        id: this.generateRequestId(),
        userId,
        requestedAt: new Date(),
        status: 'pending'
      }

      await this.storeDataExportRequest(request)

      // Log the request
      await auditService.logDataAccess(
        userId,
        'full_export',
        requestedBy,
        'GDPR data portability request'
      )

      // Process export asynchronously
      this.processDataExport(request.id)

      logger.info('GDPR', `Data export requested for user: ${userId}`)
      return request
    } catch (error) {
      logger.error('GDPR', 'Failed to request data export', error)
      throw error
    }
  }

  // Handle data deletion request (Right to be Forgotten)
  async requestDataDeletion(
    userId: string,
    requestedBy: string,
    immediateDelete: boolean = false
  ): Promise&lt;DataDeletionRequest&gt; {
    try {
      // Check if user has active subscriptions or legal holds
      const canDelete = await this.checkDeletionEligibility(userId)

      if (!canDelete.eligible) {
        throw new Error(`Cannot delete data: ${canDelete.reason}`)
      }

      const scheduledFor = immediateDelete
        ? new Date()
        : new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 days

      const request: DataDeletionRequest = {
        id: this.generateRequestId(),
        userId,
        requestedAt: new Date(),
        scheduledFor,
        status: immediateDelete ? 'pending' : 'scheduled'
      }

      await this.storeDataDeletionRequest(request)

      // Log the request
      await auditService.logAuditEvent('data_deletion_requested', 'user_data', {
        userId: requestedBy,
        resourceId: userId,
        newValues: { scheduledFor, immediateDelete },
        severity: 'high',
        category: 'data',
        complianceFlags: ['GDPR']
      })

      if (immediateDelete) {
        await this.processDataDeletion(request.id)
      }

      logger.info('GDPR', `Data deletion requested for user: ${userId}`)
      return request
    } catch (error) {
      logger.error('GDPR', 'Failed to request data deletion', error)
      throw error
    }
  }

  // Process data export
  private async processDataExport(requestId: string): Promise&lt;void&gt; {
    try {
      const request = await this.getDataExportRequest(requestId)
      if (!request) return

      // Update status to processing
      await this.updateDataExportRequest(requestId, { status: 'processing' })

      // Collect all user data
      const userData = await this.collectUserData(request.userId)

      // Generate export file
      const exportFile = await this.generateExportFile(userData)

      // Store file securely and generate download URL
      const downloadUrl = await this.storeExportFile(exportFile, request.userId)

      // Set expiration (7 days)
      const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

      // Update request with completion
      await this.updateDataExportRequest(requestId, {
        status: 'completed',
        completedAt: new Date(),
        downloadUrl,
        expiresAt
      })

      // Send notification email
      await this.sendDataExportNotification(request.userId, downloadUrl, expiresAt)

      logger.info('GDPR', `Data export completed for request: ${requestId}`)
    } catch (error) {
      await this.updateDataExportRequest(requestId, { status: 'failed' })
      logger.error('GDPR', 'Failed to process data export', error)
    }
  }

  // Process data deletion
  private async processDataDeletion(requestId: string): Promise&lt;void&gt; {
    try {
      const request = await this.getDataDeletionRequest(requestId)
      if (!request) return

      // Final eligibility check
      const canDelete = await this.checkDeletionEligibility(request.userId)
      if (!canDelete.eligible) {
        await this.updateDataDeletionRequest(requestId, {
          status: 'failed',
          retentionReason: canDelete.reason
        })
        return
      }

      // Delete user data across all systems
      await this.deleteUserData(request.userId)

      // Update request status
      await this.updateDataDeletionRequest(requestId, {
        status: 'completed',
        completedAt: new Date()
      })

      // Log completion
      await auditService.logAuditEvent('data_deletion_completed', 'user_data', {
        resourceId: request.userId,
        severity: 'critical',
        category: 'data',
        complianceFlags: ['GDPR']
      })

      logger.info('GDPR', `Data deletion completed for request: ${requestId}`)
    } catch (error) {
      await this.updateDataDeletionRequest(requestId, { status: 'failed' })
      logger.error('GDPR', 'Failed to process data deletion', error)
    }
  }

  // Check if user data can be deleted
  private async checkDeletionEligibility(userId: string): Promise&lt;{ eligible: boolean, reason?: string }&gt; {
    // Check for active subscriptions
    const subscription = await userPaymentService.getUserSubscription(userId)
    if (subscription && subscription.status === 'active') {
      return { eligible: false, reason: 'Active subscription exists' }
    }

    // Check for recent transactions (legal hold)
    const recentTransactions = await this.getRecentTransactions(userId, 90) // 90 days
    if (recentTransactions.length > 0) {
      return { eligible: false, reason: 'Recent financial transactions require retention' }
    }

    // Check for legal holds
    const legalHold = await this.checkLegalHold(userId)
    if (legalHold) {
      return { eligible: false, reason: 'Data subject to legal hold' }
    }

    return { eligible: true }
  }

  // Collect all user data for export
  private async collectUserData(userId: string): Promise&lt;any&gt; {
    const userData = {
      profile: await this.getUserProfile(userId),
      paymentData: await this.getUserPaymentData(userId),
      usageData: await this.getUserUsageData(userId),
      auditLogs: await this.getUserAuditLogs(userId),
      exportedAt: new Date()
    }

    return userData
  }

  // Delete all user data
  private async deleteUserData(userId: string): Promise&lt;void&gt; {
    // Delete from all data stores
    await Promise.all([
      this.deleteUserProfile(userId),
      this.deleteUserPaymentData(userId),
      this.deleteUserUsageData(userId),
      this.anonymizeAuditLogs(userId)
    ])
  }

  // Helper methods
  private generateRequestId(): string {
    return `gdpr_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }

  // Placeholder implementations for database operations
  private async storeDataExportRequest(request: DataExportRequest): Promise&lt;void&gt; {}
  private async storeDataDeletionRequest(request: DataDeletionRequest): Promise&lt;void&gt; {}
  private async getDataExportRequest(id: string): Promise&lt;DataExportRequest | null&gt; { return null }
  private async getDataDeletionRequest(id: string): Promise&lt;DataDeletionRequest | null&gt; { return null }
  private async updateDataExportRequest(id: string, updates: Partial&lt;DataExportRequest&gt;): Promise&lt;void&gt; {}
  private async updateDataDeletionRequest(id: string, updates: Partial&lt;DataDeletionRequest&gt;): Promise&lt;void&gt; {}
  private async getRecentTransactions(userId: string, days: number): Promise&lt;any[]&gt; { return [] }
  private async checkLegalHold(userId: string): Promise&lt;boolean&gt; { return false }
  private async getUserProfile(userId: string): Promise&lt;any&gt; { return {} }
  private async getUserPaymentData(userId: string): Promise&lt;any&gt; { return {} }
  private async getUserUsageData(userId: string): Promise&lt;any&gt; { return {} }
  private async getUserAuditLogs(userId: string): Promise&lt;any[]&gt; { return [] }
  private async generateExportFile(data: any): Promise&lt;Buffer&gt; { return Buffer.from('') }
  private async storeExportFile(file: Buffer, userId: string): Promise&lt;string&gt; { return '' }
  private async sendDataExportNotification(userId: string, url: string, expires: Date): Promise&lt;void&gt; {}
  private async deleteUserProfile(userId: string): Promise&lt;void&gt; {}
  private async deleteUserPaymentData(userId: string): Promise&lt;void&gt; {}
  private async deleteUserUsageData(userId: string): Promise&lt;void&gt; {}
  private async anonymizeAuditLogs(userId: string): Promise&lt;void&gt; {}
}

export const gdprService = new GDPRService()</pre
            >
          </div>

          <div class="validation-box">
            <h4>‚úÖ Validation Steps:</h4>
            <ul>
              <li>Test audit logging for all payment and user operations</li>
              <li>Verify GDPR data export functionality works correctly</li>
              <li>Check data deletion process respects legal holds</li>
              <li>Test compliance report generation for different standards</li>
              <li>Verify data retention policies are enforced</li>
              <li>Confirm sensitive data is properly sanitized in logs</li>
            </ul>
          </div>

          <div class="next-steps">
            <h4>üöÄ Next Steps:</h4>
            <p>Proceed to Prompt 13 for Email Notifications implementation.</p>
          </div>
        </section>

        <section id="prompt13" class="prompt-section">
          <div class="prompt-header">
            <h2>Prompt 13: Email Notifications System</h2>
            <div class="objective">
              Implement comprehensive automated email notification system for payment events,
              subscription changes, and customer communication with professional templates.
            </div>
          </div>

          <h3>Instructions for AI Assistant</h3>

          <h4>Step 1: Create Email Service</h4>
          <p>
            1. Create <code>src/model/emailService.ts</code><br />
            2. Implement comprehensive email notification system:
          </p>
          <div class="code-block">
            <pre>
import nodemailer from 'nodemailer'
import { getConfig } from '@/lib/config'
import { logger } from '@/utils/logger'
import { auditService } from './auditService'

export interface EmailTemplate {
  id: string
  name: string
  subject: string
  htmlContent: string
  textContent: string
  variables: string[]
}

export interface EmailNotification {
  id: string
  to: string
  from: string
  subject: string
  htmlContent: string
  textContent: string
  templateId?: string
  variables?: Record&lt;string, any&gt;
  status: 'pending' | 'sent' | 'failed' | 'bounced'
  sentAt?: Date
  errorMessage?: string
  userId?: string
}

export class EmailService {
  private transporter: nodemailer.Transporter
  private config = getConfig()

  constructor() {
    this.initializeTransporter()
  }

  private initializeTransporter(): void {
    this.transporter = nodemailer.createTransporter({
      host: this.config.email.smtpHost,
      port: this.config.email.smtpPort,
      secure: this.config.email.smtpSecure,
      auth: {
        user: this.config.email.smtpUser,
        pass: this.config.email.smtpPassword
      }
    })
  }

  // Send payment confirmation email
  async sendPaymentConfirmation(
    userEmail: string,
    userName: string,
    paymentDetails: {
      amount: number
      currency: string
      description: string
      transactionId: string
      date: Date
    },
    userId?: string
  ): Promise&lt;void&gt; {
    try {
      const template = await this.getEmailTemplate('payment_confirmation')

      const variables = {
        userName,
        amount: this.formatCurrency(paymentDetails.amount, paymentDetails.currency),
        description: paymentDetails.description,
        transactionId: paymentDetails.transactionId,
        date: paymentDetails.date.toLocaleDateString(),
        supportEmail: this.config.email.supportEmail
      }

      await this.sendTemplatedEmail(
        userEmail,
        template,
        variables,
        userId
      )

      logger.info('EmailService', `Payment confirmation sent to: ${userEmail}`)
    } catch (error) {
      logger.error('EmailService', 'Failed to send payment confirmation', error)
      throw error
    }
  }

  // Send subscription welcome email
  async sendSubscriptionWelcome(
    userEmail: string,
    userName: string,
    subscriptionDetails: {
      planName: string
      price: number
      currency: string
      interval: string
      features: string[]
      nextBillingDate: Date
    },
    userId?: string
  ): Promise&lt;void&gt; {
    try {
      const template = await this.getEmailTemplate('subscription_welcome')

      const variables = {
        userName,
        planName: subscriptionDetails.planName,
        price: this.formatCurrency(subscriptionDetails.price, subscriptionDetails.currency),
        interval: subscriptionDetails.interval,
        features: subscriptionDetails.features.join(', '),
        nextBillingDate: subscriptionDetails.nextBillingDate.toLocaleDateString(),
        dashboardUrl: `${this.config.app.baseUrl}/dashboard`,
        supportEmail: this.config.email.supportEmail
      }

      await this.sendTemplatedEmail(
        userEmail,
        template,
        variables,
        userId
      )

      logger.info('EmailService', `Subscription welcome sent to: ${userEmail}`)
    } catch (error) {
      logger.error('EmailService', 'Failed to send subscription welcome', error)
      throw error
    }
  }

  // Send payment failed notification
  async sendPaymentFailed(
    userEmail: string,
    userName: string,
    failureDetails: {
      amount: number
      currency: string
      reason: string
      nextRetryDate?: Date
    },
    userId?: string
  ): Promise&lt;void&gt; {
    try {
      const template = await this.getEmailTemplate('payment_failed')

      const variables = {
        userName,
        amount: this.formatCurrency(failureDetails.amount, failureDetails.currency),
        reason: failureDetails.reason,
        nextRetryDate: failureDetails.nextRetryDate?.toLocaleDateString() || 'N/A',
        updatePaymentUrl: `${this.config.app.baseUrl}/billing/payment-methods`,
        supportEmail: this.config.email.supportEmail
      }

      await this.sendTemplatedEmail(
        userEmail,
        template,
        variables,
        userId
      )

      logger.info('EmailService', `Payment failed notification sent to: ${userEmail}`)
    } catch (error) {
      logger.error('EmailService', 'Failed to send payment failed notification', error)
      throw error
    }
  }

  // Send subscription cancellation confirmation
  async sendSubscriptionCancellation(
    userEmail: string,
    userName: string,
    cancellationDetails: {
      planName: string
      endDate: Date
      reason?: string
    },
    userId?: string
  ): Promise&lt;void&gt; {
    try {
      const template = await this.getEmailTemplate('subscription_cancelled')

      const variables = {
        userName,
        planName: cancellationDetails.planName,
        endDate: cancellationDetails.endDate.toLocaleDateString(),
        reason: cancellationDetails.reason || 'Not specified',
        reactivateUrl: `${this.config.app.baseUrl}/pricing`,
        supportEmail: this.config.email.supportEmail
      }

      await this.sendTemplatedEmail(
        userEmail,
        template,
        variables,
        userId
      )

      logger.info('EmailService', `Subscription cancellation sent to: ${userEmail}`)
    } catch (error) {
      logger.error('EmailService', 'Failed to send subscription cancellation', error)
      throw error
    }
  }

  // Send invoice notification
  async sendInvoiceNotification(
    userEmail: string,
    userName: string,
    invoiceDetails: {
      invoiceNumber: string
      amount: number
      currency: string
      dueDate: Date
      downloadUrl: string
    },
    userId?: string
  ): Promise&lt;void&gt; {
    try {
      const template = await this.getEmailTemplate('invoice_notification')

      const variables = {
        userName,
        invoiceNumber: invoiceDetails.invoiceNumber,
        amount: this.formatCurrency(invoiceDetails.amount, invoiceDetails.currency),
        dueDate: invoiceDetails.dueDate.toLocaleDateString(),
        downloadUrl: invoiceDetails.downloadUrl,
        paymentUrl: `${this.config.app.baseUrl}/billing/pay-invoice`,
        supportEmail: this.config.email.supportEmail
      }

      await this.sendTemplatedEmail(
        userEmail,
        template,
        variables,
        userId
      )

      logger.info('EmailService', `Invoice notification sent to: ${userEmail}`)
    } catch (error) {
      logger.error('EmailService', 'Failed to send invoice notification', error)
      throw error
    }
  }

  // Send templated email
  private async sendTemplatedEmail(
    to: string,
    template: EmailTemplate,
    variables: Record&lt;string, any&gt;,
    userId?: string
  ): Promise&lt;void&gt; {
    try {
      const htmlContent = this.replaceVariables(template.htmlContent, variables)
      const textContent = this.replaceVariables(template.textContent, variables)
      const subject = this.replaceVariables(template.subject, variables)

      const notification: EmailNotification = {
        id: this.generateNotificationId(),
        to,
        from: this.config.email.fromAddress,
        subject,
        htmlContent,
        textContent,
        templateId: template.id,
        variables,
        status: 'pending',
        userId
      }

      await this.storeNotification(notification)

      const result = await this.transporter.sendMail({
        from: this.config.email.fromAddress,
        to,
        subject,
        html: htmlContent,
        text: textContent
      })

      await this.updateNotificationStatus(notification.id, 'sent', new Date())

      // Log email sent for audit
      await auditService.logAuditEvent('email_sent', 'notification', {
        userId,
        resourceId: notification.id,
        newValues: { to, templateId: template.id },
        severity: 'low',
        category: 'system'
      })

    } catch (error) {
      await this.updateNotificationStatus(
        notification.id,
        'failed',
        undefined,
        error.message
      )
      throw error
    }
  }

  // Replace variables in template content
  private replaceVariables(content: string, variables: Record&lt;string, any&gt;): string {
    let result = content

    Object.entries(variables).forEach(([key, value]) =&gt; {
      const regex = new RegExp(`{{\\s*${key}\\s*}}`, 'g')
      result = result.replace(regex, String(value))
    })

    return result
  }

  // Format currency
  private formatCurrency(amount: number, currency: string): string {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: currency.toUpperCase()
    }).format(amount / 100)
  }

  // Helper methods
  private generateNotificationId(): string {
    return `email_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }

  private async getEmailTemplate(templateId: string): Promise&lt;EmailTemplate&gt; {
    // Implementation would load template from database or file system
    return this.getDefaultTemplate(templateId)
  }

  private getDefaultTemplate(templateId: string): EmailTemplate {
    const templates: Record&lt;string, EmailTemplate&gt; = {
      payment_confirmation: {
        id: 'payment_confirmation',
        name: 'Payment Confirmation',
        subject: 'Payment Confirmation - {{transactionId}}',
        htmlContent: `
          &lt;h2&gt;Payment Confirmed&lt;/h2&gt;
          &lt;p&gt;Hi {{userName}},&lt;/p&gt;
          &lt;p&gt;Your payment of {{amount}} for {{description}} has been successfully processed.&lt;/p&gt;
          &lt;p&gt;&lt;strong&gt;Transaction ID:&lt;/strong&gt; {{transactionId}}&lt;/p&gt;
          &lt;p&gt;&lt;strong&gt;Date:&lt;/strong&gt; {{date}}&lt;/p&gt;
          &lt;p&gt;If you have any questions, please contact us at {{supportEmail}}.&lt;/p&gt;
        `,
        textContent: `Payment Confirmed\n\nHi {{userName}},\n\nYour payment of {{amount}} for {{description}} has been successfully processed.\n\nTransaction ID: {{transactionId}}\nDate: {{date}}\n\nIf you have any questions, please contact us at {{supportEmail}}.`,
        variables: ['userName', 'amount', 'description', 'transactionId', 'date', 'supportEmail']
      },
      // Add other default templates...
    }

    return templates[templateId] || templates.payment_confirmation
  }

  private async storeNotification(notification: EmailNotification): Promise&lt;void&gt; {
    // Implementation would store notification in database
  }

  private async updateNotificationStatus(
    id: string,
    status: string,
    sentAt?: Date,
    errorMessage?: string
  ): Promise&lt;void&gt; {
    // Implementation would update notification status in database
  }
}

export const emailService = new EmailService()</pre
            >
          </div>

          <h4>Step 2: Create Email Templates</h4>
          <p>
            1. Create <code>src/templates/email/</code> directory<br />
            2. Create professional HTML email templates:
          </p>
          <div class="code-block">
            <pre>
// src/templates/email/payment_confirmation.html
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Payment Confirmation&lt;/title&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: #667eea; color: white; padding: 20px; text-align: center; }
        .content { padding: 30px; background: #f9f9f9; }
        .footer { padding: 20px; text-align: center; font-size: 12px; color: #666; }
        .button { display: inline-block; padding: 12px 24px; background: #667eea; color: white; text-decoration: none; border-radius: 4px; }
        .transaction-details { background: white; padding: 20px; border-radius: 8px; margin: 20px 0; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;Payment Confirmed&lt;/h1&gt;
        &lt;/div&gt;

        &lt;div class="content"&gt;
            &lt;p&gt;Hi {{userName}},&lt;/p&gt;

            &lt;p&gt;Thank you for your payment! We've successfully processed your transaction.&lt;/p&gt;

            &lt;div class="transaction-details"&gt;
                &lt;h3&gt;Transaction Details&lt;/h3&gt;
                &lt;p&gt;&lt;strong&gt;Amount:&lt;/strong&gt; {{amount}}&lt;/p&gt;
                &lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; {{description}}&lt;/p&gt;
                &lt;p&gt;&lt;strong&gt;Transaction ID:&lt;/strong&gt; {{transactionId}}&lt;/p&gt;
                &lt;p&gt;&lt;strong&gt;Date:&lt;/strong&gt; {{date}}&lt;/p&gt;
            &lt;/div&gt;

            &lt;p&gt;You can view your transaction history and manage your account in your dashboard.&lt;/p&gt;

            &lt;p style="text-align: center;"&gt;
                &lt;a href="{{dashboardUrl}}" class="button"&gt;View Dashboard&lt;/a&gt;
            &lt;/p&gt;

            &lt;p&gt;If you have any questions about this transaction, please don't hesitate to contact our support team.&lt;/p&gt;
        &lt;/div&gt;

        &lt;div class="footer"&gt;
            &lt;p&gt;Need help? Contact us at {{supportEmail}}&lt;/p&gt;
            &lt;p&gt;¬© 2025 Business Scraper App. All rights reserved.&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre
            >
          </div>

          <h4>Step 3: Integrate Email Notifications with Payment Events</h4>
          <p>
            1. Update <code>src/model/userPaymentService.ts</code><br />
            2. Add email notification triggers:
          </p>
          <div class="code-block">
            <pre>
// Add to existing userPaymentService.ts
import { emailService } from './emailService'

// Update existing methods to include email notifications

// In recordPaymentSuccess method:
async recordPaymentSuccess(paymentIntent: any): Promise&lt;void&gt; {
  try {
    // ... existing payment recording logic

    // Send payment confirmation email
    const user = await this.getUserById(paymentIntent.customer)
    if (user) {
      await emailService.sendPaymentConfirmation(
        user.email,
        user.name,
        {
          amount: paymentIntent.amount,
          currency: paymentIntent.currency,
          description: paymentIntent.description || 'Payment',
          transactionId: paymentIntent.id,
          date: new Date()
        },
        user.id
      )
    }
  } catch (error) {
    logger.error('UserPaymentService', 'Failed to record payment success', error)
    throw error
  }
}

// In createSubscription method:
async createSubscription(subscriptionData: any): Promise&lt;void&gt; {
  try {
    // ... existing subscription creation logic

    // Send welcome email
    const user = await this.getUserById(subscriptionData.userId)
    const plan = await this.getSubscriptionPlan(subscriptionData.planId)

    if (user && plan) {
      await emailService.sendSubscriptionWelcome(
        user.email,
        user.name,
        {
          planName: plan.name,
          price: plan.priceCents,
          currency: plan.currency,
          interval: plan.interval,
          features: plan.features,
          nextBillingDate: subscriptionData.currentPeriodEnd
        },
        user.id
      )
    }
  } catch (error) {
    logger.error('UserPaymentService', 'Failed to create subscription', error)
    throw error
  }
}

// In recordPaymentFailure method:
async recordPaymentFailure(paymentIntent: any): Promise&lt;void&gt; {
  try {
    // ... existing failure recording logic

    // Send payment failed notification
    const user = await this.getUserById(paymentIntent.customer)
    if (user) {
      await emailService.sendPaymentFailed(
        user.email,
        user.name,
        {
          amount: paymentIntent.amount,
          currency: paymentIntent.currency,
          reason: paymentIntent.last_payment_error?.message || 'Payment failed'
        },
        user.id
      )
    }
  } catch (error) {
    logger.error('UserPaymentService', 'Failed to record payment failure', error)
    throw error
  }
}</pre
            >
          </div>

          <div class="validation-box">
            <h4>‚úÖ Validation Steps:</h4>
            <ul>
              <li>Test email sending for all payment event types</li>
              <li>Verify email templates render correctly with dynamic content</li>
              <li>Check email delivery and bounce handling</li>
              <li>Test email notifications are properly logged for audit</li>
              <li>Verify unsubscribe functionality works correctly</li>
              <li>Test email templates on different email clients</li>
            </ul>
          </div>

          <div class="next-steps">
            <h4>üöÄ Next Steps:</h4>
            <p>Proceed to Prompt 14 for Performance Monitoring implementation.</p>
          </div>
        </section>

        <section id="prompt14" class="prompt-section">
          <div class="prompt-header">
            <h2>Prompt 14: Performance Monitoring and Alerting</h2>
            <div class="objective">
              Implement comprehensive performance monitoring, real-time alerting, and health checks
              for the payment system with automated incident response.
            </div>
          </div>

          <h3>Instructions for AI Assistant</h3>

          <h4>Step 1: Create Performance Monitoring Service</h4>
          <p>
            1. Create <code>src/model/monitoringService.ts</code><br />
            2. Implement comprehensive performance monitoring:
          </p>
          <div class="code-block">
            <pre>
import { logger } from '@/utils/logger'
import { auditService } from './auditService'

export interface PerformanceMetric {
  id: string
  name: string
  value: number
  unit: string
  timestamp: Date
  tags?: Record&lt;string, string&gt;
  threshold?: {
    warning: number
    critical: number
  }
}

export interface HealthCheck {
  service: string
  status: 'healthy' | 'degraded' | 'unhealthy'
  responseTime: number
  lastCheck: Date
  details?: Record&lt;string, any&gt;
  error?: string
}

export interface Alert {
  id: string
  type: 'performance' | 'error' | 'security' | 'business'
  severity: 'low' | 'medium' | 'high' | 'critical'
  title: string
  description: string
  metric?: string
  value?: number
  threshold?: number
  timestamp: Date
  resolved: boolean
  resolvedAt?: Date
  acknowledgedBy?: string
  acknowledgedAt?: Date
}

export class MonitoringService {
  private metrics: Map&lt;string, PerformanceMetric[]&gt; = new Map()
  private healthChecks: Map&lt;string, HealthCheck&gt; = new Map()
  private alerts: Alert[] = []
  private alertThresholds: Map&lt;string, any&gt; = new Map()

  constructor() {
    this.initializeThresholds()
    this.startHealthChecks()
  }

  // Record performance metric
  async recordMetric(
    name: string,
    value: number,
    unit: string,
    tags?: Record&lt;string, string&gt;
  ): Promise&lt;void&gt; {
    try {
      const metric: PerformanceMetric = {
        id: this.generateMetricId(),
        name,
        value,
        unit,
        timestamp: new Date(),
        tags,
        threshold: this.alertThresholds.get(name)
      }

      // Store metric
      if (!this.metrics.has(name)) {
        this.metrics.set(name, [])
      }
      this.metrics.get(name)!.push(metric)

      // Keep only last 1000 metrics per type
      const metricArray = this.metrics.get(name)!
      if (metricArray.length > 1000) {
        metricArray.splice(0, metricArray.length - 1000)
      }

      // Check thresholds and create alerts
      await this.checkThresholds(metric)

      // Store in persistent storage
      await this.storeMetric(metric)

      logger.debug('Monitoring', `Metric recorded: ${name} = ${value} ${unit}`)
    } catch (error) {
      logger.error('Monitoring', 'Failed to record metric', error)
    }
  }

  // Record payment processing time
  async recordPaymentProcessingTime(duration: number, success: boolean): Promise&lt;void&gt; {
    await this.recordMetric('payment_processing_time', duration, 'ms', {
      success: success.toString()
    })

    if (!success) {
      await this.recordMetric('payment_failures', 1, 'count')
    }
  }

  // Record API response time
  async recordApiResponseTime(endpoint: string, duration: number, statusCode: number): Promise&lt;void&gt; {
    await this.recordMetric('api_response_time', duration, 'ms', {
      endpoint,
      status_code: statusCode.toString()
    })

    if (statusCode >= 400) {
      await this.recordMetric('api_errors', 1, 'count', {
        endpoint,
        status_code: statusCode.toString()
      })
    }
  }

  // Record database query time
  async recordDatabaseQueryTime(query: string, duration: number): Promise&lt;void&gt; {
    await this.recordMetric('database_query_time', duration, 'ms', {
      query_type: this.getQueryType(query)
    })
  }

  // Record memory usage
  async recordMemoryUsage(): Promise&lt;void&gt; {
    if (typeof process !== 'undefined') {
      const memUsage = process.memoryUsage()
      await this.recordMetric('memory_heap_used', memUsage.heapUsed, 'bytes')
      await this.recordMetric('memory_heap_total', memUsage.heapTotal, 'bytes')
      await this.recordMetric('memory_rss', memUsage.rss, 'bytes')
    }
  }

  // Perform health check
  async performHealthCheck(serviceName: string): Promise&lt;HealthCheck&gt; {
    const startTime = Date.now()
    let healthCheck: HealthCheck

    try {
      const result = await this.checkServiceHealth(serviceName)
      const responseTime = Date.now() - startTime

      healthCheck = {
        service: serviceName,
        status: result.healthy ? 'healthy' : 'degraded',
        responseTime,
        lastCheck: new Date(),
        details: result.details
      }

      if (!result.healthy && result.error) {
        healthCheck.error = result.error
        healthCheck.status = 'unhealthy'
      }
    } catch (error) {
      healthCheck = {
        service: serviceName,
        status: 'unhealthy',
        responseTime: Date.now() - startTime,
        lastCheck: new Date(),
        error: error.message
      }
    }

    this.healthChecks.set(serviceName, healthCheck)

    // Create alert if service is unhealthy
    if (healthCheck.status === 'unhealthy') {
      await this.createAlert({
        type: 'performance',
        severity: 'critical',
        title: `Service ${serviceName} is unhealthy`,
        description: `Health check failed: ${healthCheck.error}`,
        metric: `health_check_${serviceName}`,
        value: 0,
        threshold: 1
      })
    }

    return healthCheck
  }

  // Get system health overview
  getSystemHealth(): {
    overall: 'healthy' | 'degraded' | 'unhealthy'
    services: HealthCheck[]
    activeAlerts: number
    lastUpdated: Date
  } {
    const services = Array.from(this.healthChecks.values())
    const unhealthyServices = services.filter(s =&gt; s.status === 'unhealthy')
    const degradedServices = services.filter(s =&gt; s.status === 'degraded')

    let overall: 'healthy' | 'degraded' | 'unhealthy' = 'healthy'
    if (unhealthyServices.length > 0) {
      overall = 'unhealthy'
    } else if (degradedServices.length > 0) {
      overall = 'degraded'
    }

    return {
      overall,
      services,
      activeAlerts: this.alerts.filter(a =&gt; !a.resolved).length,
      lastUpdated: new Date()
    }
  }

  // Create alert
  async createAlert(alertData: {
    type: 'performance' | 'error' | 'security' | 'business'
    severity: 'low' | 'medium' | 'high' | 'critical'
    title: string
    description: string
    metric?: string
    value?: number
    threshold?: number
  }): Promise&lt;Alert&gt; {
    const alert: Alert = {
      id: this.generateAlertId(),
      ...alertData,
      timestamp: new Date(),
      resolved: false
    }

    this.alerts.push(alert)

    // Log alert for audit
    await auditService.logAuditEvent('alert_created', 'monitoring', {
      resourceId: alert.id,
      newValues: alert,
      severity: alert.severity === 'critical' ? 'critical' : 'high',
      category: 'system'
    })

    // Send notifications based on severity
    await this.sendAlertNotifications(alert)

    logger.warn('Monitoring', `Alert created: ${alert.title}`, alert)
    return alert
  }

  // Resolve alert
  async resolveAlert(alertId: string, resolvedBy: string): Promise&lt;void&gt; {
    const alert = this.alerts.find(a =&gt; a.id === alertId)
    if (alert && !alert.resolved) {
      alert.resolved = true
      alert.resolvedAt = new Date()

      await auditService.logAuditEvent('alert_resolved', 'monitoring', {
        userId: resolvedBy,
        resourceId: alertId,
        severity: 'medium',
        category: 'system'
      })

      logger.info('Monitoring', `Alert resolved: ${alert.title}`)
    }
  }

  // Get performance metrics
  getMetrics(metricName?: string, timeRange?: { start: Date, end: Date }): PerformanceMetric[] {
    if (metricName) {
      const metrics = this.metrics.get(metricName) || []
      if (timeRange) {
        return metrics.filter(m =&gt;
          m.timestamp >= timeRange.start && m.timestamp <= timeRange.end
        )
      }
      return metrics
    }

    // Return all metrics
    const allMetrics: PerformanceMetric[] = []
    this.metrics.forEach(metrics =&gt; allMetrics.push(...metrics))

    if (timeRange) {
      return allMetrics.filter(m =&gt;
        m.timestamp >= timeRange.start && m.timestamp <= timeRange.end
      )
    }

    return allMetrics
  }

  // Initialize alert thresholds
  private initializeThresholds(): void {
    this.alertThresholds.set('payment_processing_time', {
      warning: 5000, // 5 seconds
      critical: 10000 // 10 seconds
    })

    this.alertThresholds.set('api_response_time', {
      warning: 1000, // 1 second
      critical: 3000 // 3 seconds
    })

    this.alertThresholds.set('database_query_time', {
      warning: 500, // 500ms
      critical: 2000 // 2 seconds
    })

    this.alertThresholds.set('memory_heap_used', {
      warning: 500 * 1024 * 1024, // 500MB
      critical: 1024 * 1024 * 1024 // 1GB
    })
  }

  // Start periodic health checks
  private startHealthChecks(): void {
    const services = ['database', 'stripe', 'email', 'storage']

    // Check every 30 seconds
    setInterval(async () =&gt; {
      for (const service of services) {
        await this.performHealthCheck(service)
      }
      await this.recordMemoryUsage()
    }, 30000)
  }

  // Check metric thresholds
  private async checkThresholds(metric: PerformanceMetric): Promise&lt;void&gt; {
    if (!metric.threshold) return

    if (metric.value >= metric.threshold.critical) {
      await this.createAlert({
        type: 'performance',
        severity: 'critical',
        title: `Critical threshold exceeded: ${metric.name}`,
        description: `${metric.name} is ${metric.value} ${metric.unit}, exceeding critical threshold of ${metric.threshold.critical} ${metric.unit}`,
        metric: metric.name,
        value: metric.value,
        threshold: metric.threshold.critical
      })
    } else if (metric.value >= metric.threshold.warning) {
      await this.createAlert({
        type: 'performance',
        severity: 'medium',
        title: `Warning threshold exceeded: ${metric.name}`,
        description: `${metric.name} is ${metric.value} ${metric.unit}, exceeding warning threshold of ${metric.threshold.warning} ${metric.unit}`,
        metric: metric.name,
        value: metric.value,
        threshold: metric.threshold.warning
      })
    }
  }

  // Check individual service health
  private async checkServiceHealth(serviceName: string): Promise&lt;{ healthy: boolean, details?: any, error?: string }&gt; {
    switch (serviceName) {
      case 'database':
        return this.checkDatabaseHealth()
      case 'stripe':
        return this.checkStripeHealth()
      case 'email':
        return this.checkEmailHealth()
      case 'storage':
        return this.checkStorageHealth()
      default:
        return { healthy: false, error: 'Unknown service' }
    }
  }

  // Service-specific health checks
  private async checkDatabaseHealth(): Promise&lt;{ healthy: boolean, details?: any, error?: string }&gt; {
    try {
      // Implementation would check database connectivity
      return { healthy: true, details: { connection: 'active' } }
    } catch (error) {
      return { healthy: false, error: error.message }
    }
  }

  private async checkStripeHealth(): Promise&lt;{ healthy: boolean, details?: any, error?: string }&gt; {
    try {
      // Implementation would check Stripe API connectivity
      return { healthy: true, details: { api: 'responsive' } }
    } catch (error) {
      return { healthy: false, error: error.message }
    }
  }

  private async checkEmailHealth(): Promise&lt;{ healthy: boolean, details?: any, error?: string }&gt; {
    try {
      // Implementation would check email service connectivity
      return { healthy: true, details: { smtp: 'connected' } }
    } catch (error) {
      return { healthy: false, error: error.message }
    }
  }

  private async checkStorageHealth(): Promise&lt;{ healthy: boolean, details?: any, error?: string }&gt; {
    try {
      // Implementation would check storage system
      return { healthy: true, details: { storage: 'available' } }
    } catch (error) {
      return { healthy: false, error: error.message }
    }
  }

  // Send alert notifications
  private async sendAlertNotifications(alert: Alert): Promise&lt;void&gt; {
    if (alert.severity === 'critical') {
      // Send immediate notifications (email, SMS, Slack, etc.)
      logger.error('Monitoring', `CRITICAL ALERT: ${alert.title}`, alert)
    }
  }

  // Helper methods
  private generateMetricId(): string {
    return `metric_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }

  private generateAlertId(): string {
    return `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }

  private getQueryType(query: string): string {
    const lowerQuery = query.toLowerCase().trim()
    if (lowerQuery.startsWith('select')) return 'select'
    if (lowerQuery.startsWith('insert')) return 'insert'
    if (lowerQuery.startsWith('update')) return 'update'
    if (lowerQuery.startsWith('delete')) return 'delete'
    return 'other'
  }

  private async storeMetric(metric: PerformanceMetric): Promise&lt;void&gt; {
    // Implementation would store metric in time-series database
  }
}

export const monitoringService = new MonitoringService()</pre
            >
          </div>

          <h4>Step 2: Create Performance Middleware</h4>
          <p>
            1. Create <code>src/middleware/performanceMiddleware.ts</code><br />
            2. Implement automatic performance tracking:
          </p>
          <div class="code-block">
            <pre>
import { NextApiRequest, NextApiResponse } from 'next'
import { monitoringService } from '@/model/monitoringService'
import { logger } from '@/utils/logger'

export function performanceMiddleware(
  req: NextApiRequest,
  res: NextApiResponse,
  next: () =&gt; void
): void {
  const startTime = Date.now()
  const endpoint = req.url || 'unknown'

  // Track request start
  logger.debug('Performance', `Request started: ${req.method} ${endpoint}`)

  // Override res.end to capture response time
  const originalEnd = res.end
  res.end = function(chunk?: any, encoding?: any) {
    const duration = Date.now() - startTime
    const statusCode = res.statusCode

    // Record API response time
    monitoringService.recordApiResponseTime(endpoint, duration, statusCode)

    // Log slow requests
    if (duration > 1000) {
      logger.warn('Performance', `Slow request detected: ${req.method} ${endpoint} took ${duration}ms`)
    }

    // Call original end method
    originalEnd.call(this, chunk, encoding)
  }

  next()
}

// Database query performance wrapper
export function withDatabasePerformanceTracking&lt;T&gt;(
  queryName: string,
  queryFunction: () =&gt; Promise&lt;T&gt;
): Promise&lt;T&gt; {
  return new Promise(async (resolve, reject) =&gt; {
    const startTime = Date.now()

    try {
      const result = await queryFunction()
      const duration = Date.now() - startTime

      await monitoringService.recordDatabaseQueryTime(queryName, duration)

      if (duration > 500) {
        logger.warn('Performance', `Slow database query: ${queryName} took ${duration}ms`)
      }

      resolve(result)
    } catch (error) {
      const duration = Date.now() - startTime
      await monitoringService.recordDatabaseQueryTime(queryName, duration)

      logger.error('Performance', `Database query failed: ${queryName}`, error)
      reject(error)
    }
  })
}

// Payment processing performance wrapper
export function withPaymentPerformanceTracking&lt;T&gt;(
  operation: string,
  paymentFunction: () =&gt; Promise&lt;T&gt;
): Promise&lt;T&gt; {
  return new Promise(async (resolve, reject) =&gt; {
    const startTime = Date.now()

    try {
      const result = await paymentFunction()
      const duration = Date.now() - startTime

      await monitoringService.recordPaymentProcessingTime(duration, true)

      logger.info('Performance', `Payment operation completed: ${operation} in ${duration}ms`)
      resolve(result)
    } catch (error) {
      const duration = Date.now() - startTime
      await monitoringService.recordPaymentProcessingTime(duration, false)

      logger.error('Performance', `Payment operation failed: ${operation}`, error)
      reject(error)
    }
  })
}</pre
            >
          </div>

          <div class="validation-box">
            <h4>‚úÖ Validation Steps:</h4>
            <ul>
              <li>Test performance monitoring captures all key metrics</li>
              <li>Verify health checks work for all services</li>
              <li>Check alert creation and notification system</li>
              <li>Test performance middleware tracks API response times</li>
              <li>Verify database and payment performance tracking</li>
              <li>Confirm system health dashboard displays correctly</li>
            </ul>
          </div>

          <div class="next-steps">
            <h4>üöÄ Next Steps:</h4>
            <p>Proceed to Prompt 15 for Dashboard Integration - the final implementation step.</p>
          </div>
        </section>

        <section id="prompt15" class="prompt-section">
          <div class="prompt-header">
            <h2>Prompt 15: Dashboard Integration - Admin Interface</h2>
            <div class="objective">
              Create comprehensive admin dashboard for payment system management, user
              administration, analytics visualization, and system monitoring with role-based access
              control.
            </div>
          </div>

          <h3>Instructions for AI Assistant</h3>

          <h4>Step 1: Create Admin Dashboard Layout</h4>
          <p>
            1. Create <code>src/view/components/admin/AdminDashboard.tsx</code><br />
            2. Implement comprehensive admin interface:
          </p>
          <div class="code-block">
            <pre>
import React, { useState, useEffect } from 'react'
import { analyticsService } from '@/model/analyticsService'
import { monitoringService } from '@/model/monitoringService'
import { auditService } from '@/model/auditService'
import { Card } from '@/view/components/ui/Card'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/view/components/ui/Tabs'
import { Button } from '@/view/components/ui/Button'
import { Badge } from '@/view/components/ui/Badge'
import { LineChart, BarChart, PieChart } from '@/view/components/ui/Charts'

interface AdminDashboardProps {
  user: any // Admin user
}

export const AdminDashboard: React.FC&lt;AdminDashboardProps&gt; = ({ user }) =&gt; {
  const [systemHealth, setSystemHealth] = useState&lt;any&gt;(null)
  const [revenueMetrics, setRevenueMetrics] = useState&lt;any&gt;(null)
  const [userMetrics, setUserMetrics] = useState&lt;any&gt;(null)
  const [recentAlerts, setRecentAlerts] = useState&lt;any[]&gt;([])
  const [auditLogs, setAuditLogs] = useState&lt;any[]&gt;([])
  const [loading, setLoading] = useState(true)

  useEffect(() =&gt; {
    loadDashboardData()

    // Refresh data every 30 seconds
    const interval = setInterval(loadDashboardData, 30000)
    return () =&gt; clearInterval(interval)
  }, [])

  const loadDashboardData = async () =&gt; {
    try {
      const endDate = new Date()
      const startDate = new Date()
      startDate.setDate(endDate.getDate() - 30)

      const [health, revenue, users, alerts, logs] = await Promise.all([
        monitoringService.getSystemHealth(),
        analyticsService.getRevenueMetrics(startDate, endDate),
        analyticsService.getUserMetrics(startDate, endDate),
        monitoringService.getRecentAlerts(10),
        auditService.getAuditLogs({ limit: 20 })
      ])

      setSystemHealth(health)
      setRevenueMetrics(revenue)
      setUserMetrics(users)
      setRecentAlerts(alerts)
      setAuditLogs(logs.logs)
    } catch (error) {
      console.error('Failed to load dashboard data:', error)
    } finally {
      setLoading(false)
    }
  }

  const getHealthStatusColor = (status: string) =&gt; {
    switch (status) {
      case 'healthy': return 'text-green-600'
      case 'degraded': return 'text-yellow-600'
      case 'unhealthy': return 'text-red-600'
      default: return 'text-gray-600'
    }
  }

  const getAlertSeverityColor = (severity: string) =&gt; {
    switch (severity) {
      case 'critical': return 'bg-red-100 text-red-800'
      case 'high': return 'bg-orange-100 text-orange-800'
      case 'medium': return 'bg-yellow-100 text-yellow-800'
      case 'low': return 'bg-blue-100 text-blue-800'
      default: return 'bg-gray-100 text-gray-800'
    }
  }

  const formatCurrency = (amount: number) =&gt; {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD'
    }).format(amount)
  }

  if (loading) {
    return &lt;div className="flex justify-center p-8"&gt;Loading admin dashboard...&lt;/div&gt;
  }

  return (
    &lt;div className="space-y-6"&gt;
      {/* Header */}
      &lt;div className="flex justify-between items-center"&gt;
        &lt;div&gt;
          &lt;h1 className="text-3xl font-bold"&gt;Admin Dashboard&lt;/h1&gt;
          &lt;p className="text-gray-600"&gt;Welcome back, {user.name}&lt;/p&gt;
        &lt;/div&gt;
        &lt;div className="flex space-x-4"&gt;
          &lt;Button onClick={loadDashboardData}&gt;Refresh Data&lt;/Button&gt;
          &lt;Button variant="outline"&gt;Export Report&lt;/Button&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      {/* System Health Overview */}
      {systemHealth && (
        &lt;Card className="p-6"&gt;
          &lt;div className="flex justify-between items-center mb-4"&gt;
            &lt;h2 className="text-xl font-bold"&gt;System Health&lt;/h2&gt;
            &lt;Badge className={getHealthStatusColor(systemHealth.overall)}&gt;
              {systemHealth.overall.toUpperCase()}
            &lt;/Badge&gt;
          &lt;/div&gt;

          &lt;div className="grid grid-cols-1 md:grid-cols-4 gap-4"&gt;
            {systemHealth.services.map((service: any) =&gt; (
              &lt;div key={service.service} className="p-4 border rounded-lg"&gt;
                &lt;div className="flex justify-between items-center mb-2"&gt;
                  &lt;span className="font-medium capitalize"&gt;{service.service}&lt;/span&gt;
                  &lt;Badge className={getHealthStatusColor(service.status)}&gt;
                    {service.status}
                  &lt;/Badge&gt;
                &lt;/div&gt;
                &lt;p className="text-sm text-gray-600"&gt;
                  Response: {service.responseTime}ms
                &lt;/p&gt;
                &lt;p className="text-xs text-gray-500"&gt;
                  Last check: {new Date(service.lastCheck).toLocaleTimeString()}
                &lt;/p&gt;
              &lt;/div&gt;
            ))}
          &lt;/div&gt;
        &lt;/Card&gt;
      )}

      {/* Key Metrics */}
      {revenueMetrics && userMetrics && (
        &lt;div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6"&gt;
          &lt;Card className="p-6"&gt;
            &lt;h3 className="text-sm font-medium text-gray-600"&gt;Total Revenue (30d)&lt;/h3&gt;
            &lt;p className="text-2xl font-bold text-green-600"&gt;
              {formatCurrency(revenueMetrics.totalRevenue)}
            &lt;/p&gt;
          &lt;/Card&gt;
          &lt;Card className="p-6"&gt;
            &lt;h3 className="text-sm font-medium text-gray-600"&gt;Monthly Recurring Revenue&lt;/h3&gt;
            &lt;p className="text-2xl font-bold text-blue-600"&gt;
              {formatCurrency(revenueMetrics.monthlyRecurringRevenue)}
            &lt;/p&gt;
          &lt;/Card&gt;
          &lt;Card className="p-6"&gt;
            &lt;h3 className="text-sm font-medium text-gray-600"&gt;Active Users&lt;/h3&gt;
            &lt;p className="text-2xl font-bold"&gt;{userMetrics.activeUsers.toLocaleString()}&lt;/p&gt;
          &lt;/Card&gt;
          &lt;Card className="p-6"&gt;
            &lt;h3 className="text-sm font-medium text-gray-600"&gt;Active Alerts&lt;/h3&gt;
            &lt;p className="text-2xl font-bold text-red-600"&gt;{systemHealth.activeAlerts}&lt;/p&gt;
          &lt;/Card&gt;
        &lt;/div&gt;
      )}

      {/* Detailed Tabs */}
      &lt;Tabs defaultValue="analytics" className="space-y-4"&gt;
        &lt;TabsList&gt;
          &lt;TabsTrigger value="analytics"&gt;Analytics&lt;/TabsTrigger&gt;
          &lt;TabsTrigger value="users"&gt;User Management&lt;/TabsTrigger&gt;
          &lt;TabsTrigger value="payments"&gt;Payment Management&lt;/TabsTrigger&gt;
          &lt;TabsTrigger value="monitoring"&gt;Monitoring&lt;/TabsTrigger&gt;
          &lt;TabsTrigger value="audit"&gt;Audit Logs&lt;/TabsTrigger&gt;
        &lt;/TabsList&gt;

        &lt;TabsContent value="analytics" className="space-y-6"&gt;
          &lt;div className="grid grid-cols-1 lg:grid-cols-2 gap-6"&gt;
            &lt;Card className="p-6"&gt;
              &lt;h3 className="text-lg font-bold mb-4"&gt;Revenue Trend&lt;/h3&gt;
              &lt;LineChart
                data={[]} // Would be populated with actual revenue data
                height={300}
              /&gt;
            &lt;/Card&gt;
            &lt;Card className="p-6"&gt;
              &lt;h3 className="text-lg font-bold mb-4"&gt;User Growth&lt;/h3&gt;
              &lt;LineChart
                data={[]} // Would be populated with actual user data
                height={300}
              /&gt;
            &lt;/Card&gt;
          &lt;/div&gt;
        &lt;/TabsContent&gt;

        &lt;TabsContent value="users" className="space-y-6"&gt;
          &lt;Card className="p-6"&gt;
            &lt;h3 className="text-lg font-bold mb-4"&gt;User Management&lt;/h3&gt;
            &lt;div className="space-y-4"&gt;
              &lt;div className="flex justify-between items-center"&gt;
                &lt;span&gt;Total Users: {userMetrics?.totalUsers.toLocaleString()}&lt;/span&gt;
                &lt;Button&gt;Export User List&lt;/Button&gt;
              &lt;/div&gt;
              &lt;div className="grid grid-cols-1 md:grid-cols-3 gap-4"&gt;
                &lt;div className="p-4 border rounded-lg"&gt;
                  &lt;h4 className="font-medium"&gt;Free Users&lt;/h4&gt;
                  &lt;p className="text-2xl font-bold"&gt;{userMetrics?.freeUsers || 0}&lt;/p&gt;
                &lt;/div&gt;
                &lt;div className="p-4 border rounded-lg"&gt;
                  &lt;h4 className="font-medium"&gt;Paid Users&lt;/h4&gt;
                  &lt;p className="text-2xl font-bold"&gt;{userMetrics?.paidUsers || 0}&lt;/p&gt;
                &lt;/div&gt;
                &lt;div className="p-4 border rounded-lg"&gt;
                  &lt;h4 className="font-medium"&gt;Churn Rate&lt;/h4&gt;
                  &lt;p className="text-2xl font-bold"&gt;{((revenueMetrics?.churnRate || 0) * 100).toFixed(1)}%&lt;/p&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/Card&gt;
        &lt;/TabsContent&gt;

        &lt;TabsContent value="payments" className="space-y-6"&gt;
          &lt;Card className="p-6"&gt;
            &lt;h3 className="text-lg font-bold mb-4"&gt;Payment Overview&lt;/h3&gt;
            &lt;div className="grid grid-cols-1 md:grid-cols-3 gap-4"&gt;
              &lt;div className="p-4 border rounded-lg"&gt;
                &lt;h4 className="font-medium"&gt;Successful Payments&lt;/h4&gt;
                &lt;p className="text-2xl font-bold text-green-600"&gt;98.5%&lt;/p&gt;
              &lt;/div&gt;
              &lt;div className="p-4 border rounded-lg"&gt;
                &lt;h4 className="font-medium"&gt;Failed Payments&lt;/h4&gt;
                &lt;p className="text-2xl font-bold text-red-600"&gt;1.5%&lt;/p&gt;
              &lt;/div&gt;
              &lt;div className="p-4 border rounded-lg"&gt;
                &lt;h4 className="font-medium"&gt;Avg Processing Time&lt;/h4&gt;
                &lt;p className="text-2xl font-bold"&gt;2.3s&lt;/p&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/Card&gt;
        &lt;/TabsContent&gt;

        &lt;TabsContent value="monitoring" className="space-y-6"&gt;
          &lt;Card className="p-6"&gt;
            &lt;h3 className="text-lg font-bold mb-4"&gt;Recent Alerts&lt;/h3&gt;
            &lt;div className="space-y-3"&gt;
              {recentAlerts.map((alert: any) =&gt; (
                &lt;div key={alert.id} className="flex justify-between items-center p-3 border rounded-lg"&gt;
                  &lt;div&gt;
                    &lt;div className="flex items-center space-x-2"&gt;
                      &lt;Badge className={getAlertSeverityColor(alert.severity)}&gt;
                        {alert.severity}
                      &lt;/Badge&gt;
                      &lt;span className="font-medium"&gt;{alert.title}&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;p className="text-sm text-gray-600"&gt;{alert.description}&lt;/p&gt;
                    &lt;p className="text-xs text-gray-500"&gt;
                      {new Date(alert.timestamp).toLocaleString()}
                    &lt;/p&gt;
                  &lt;/div&gt;
                  &lt;div className="flex space-x-2"&gt;
                    {!alert.resolved && (
                      &lt;Button size="sm" onClick={() =&gt; resolveAlert(alert.id)}&gt;
                        Resolve
                      &lt;/Button&gt;
                    )}
                  &lt;/div&gt;
                &lt;/div&gt;
              ))}
            &lt;/div&gt;
          &lt;/Card&gt;
        &lt;/TabsContent&gt;

        &lt;TabsContent value="audit" className="space-y-6"&gt;
          &lt;Card className="p-6"&gt;
            &lt;h3 className="text-lg font-bold mb-4"&gt;Recent Audit Logs&lt;/h3&gt;
            &lt;div className="space-y-3"&gt;
              {auditLogs.map((log: any) =&gt; (
                &lt;div key={log.id} className="p-3 border rounded-lg"&gt;
                  &lt;div className="flex justify-between items-start"&gt;
                    &lt;div&gt;
                      &lt;div className="flex items-center space-x-2"&gt;
                        &lt;Badge&gt;{log.category}&lt;/Badge&gt;
                        &lt;span className="font-medium"&gt;{log.action}&lt;/span&gt;
                      &lt;/div&gt;
                      &lt;p className="text-sm text-gray-600"&gt;Resource: {log.resource}&lt;/p&gt;
                      &lt;p className="text-xs text-gray-500"&gt;
                        {new Date(log.timestamp).toLocaleString()}
                      &lt;/p&gt;
                    &lt;/div&gt;
                    &lt;Badge className={getAlertSeverityColor(log.severity)}&gt;
                      {log.severity}
                    &lt;/Badge&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
              ))}
            &lt;/div&gt;
          &lt;/Card&gt;
        &lt;/TabsContent&gt;
      &lt;/Tabs&gt;
    &lt;/div&gt;
  )

  async function resolveAlert(alertId: string) {
    try {
      await monitoringService.resolveAlert(alertId, user.id)
      await loadDashboardData()
    } catch (error) {
      console.error('Failed to resolve alert:', error)
    }
  }
}</pre
            >
          </div>

          <h4>Step 2: Create Admin Routes and Access Control</h4>
          <p>
            1. Create <code>src/pages/admin/index.tsx</code><br />
            2. Implement admin route with role-based access:
          </p>
          <div class="code-block">
            <pre>
import { GetServerSideProps } from 'next'
import { AdminDashboard } from '@/view/components/admin/AdminDashboard'
import { authenticateUser, checkAdminRole } from '@/utils/auth'

interface AdminPageProps {
  user: any
}

export default function AdminPage({ user }: AdminPageProps) {
  return (
    &lt;div className="min-h-screen bg-gray-50"&gt;
      &lt;div className="container mx-auto px-4 py-8"&gt;
        &lt;AdminDashboard user={user} /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  )
}

export const getServerSideProps: GetServerSideProps = async (context) =&gt; {
  try {
    // Authenticate user
    const user = await authenticateUser(context.req)

    if (!user) {
      return {
        redirect: {
          destination: '/login',
          permanent: false
        }
      }
    }

    // Check admin role
    const isAdmin = await checkAdminRole(user.id)

    if (!isAdmin) {
      return {
        redirect: {
          destination: '/dashboard',
          permanent: false
        }
      }
    }

    return {
      props: {
        user
      }
    }
  } catch (error) {
    return {
      redirect: {
        destination: '/login',
        permanent: false
      }
    }
  }
}</pre
            >
          </div>

          <h4>Step 3: Final Integration and Documentation Updates</h4>
          <p>
            1. Update <code>README.md</code> with complete implementation summary:<br />
            2. Update <code>CHANGELOG.md</code> with all new features:<br />
            3. Create final deployment checklist:
          </p>
          <div class="code-block">
            <pre>
# Stripe Payment System - Final Implementation Summary

## ‚úÖ Implementation Complete

The comprehensive Stripe payment integration has been successfully implemented with the following components:

### Core Features
- ‚úÖ Complete Stripe integration with webhooks
- ‚úÖ Subscription management and billing
- ‚úÖ Payment processing and transaction tracking
- ‚úÖ User onboarding and payment profiles
- ‚úÖ Feature access control and usage tracking

### Security & Compliance
- ‚úÖ PCI DSS compliance measures
- ‚úÖ GDPR data protection and user rights
- ‚úÖ SOC 2 audit logging
- ‚úÖ Comprehensive security middleware
- ‚úÖ Data encryption and sanitization

### Analytics & Monitoring
- ‚úÖ Business intelligence dashboard
- ‚úÖ Revenue and user analytics
- ‚úÖ Real-time performance monitoring
- ‚úÖ Automated alerting system
- ‚úÖ Health checks and system monitoring

### Communication & Support
- ‚úÖ Automated email notifications
- ‚úÖ Professional email templates
- ‚úÖ Customer communication workflows
- ‚úÖ Support ticket integration

### Administration
- ‚úÖ Comprehensive admin dashboard
- ‚úÖ User management interface
- ‚úÖ Payment system administration
- ‚úÖ Audit log viewing and management
- ‚úÖ Role-based access control

## Deployment Checklist

### Environment Setup
- [ ] Configure production Stripe keys
- [ ] Set up webhook endpoints
- [ ] Configure email service (SMTP)
- [ ] Set up monitoring alerts
- [ ] Configure database backups

### Security Configuration
- [ ] Enable HTTPS/SSL certificates
- [ ] Configure CSP headers
- [ ] Set up rate limiting
- [ ] Enable audit logging
- [ ] Configure data retention policies

### Testing
- [ ] Run complete test suite
- [ ] Test payment flows end-to-end
- [ ] Verify webhook processing
- [ ] Test email notifications
- [ ] Validate monitoring and alerts

### Go-Live
- [ ] Deploy to production
- [ ] Verify all services are healthy
- [ ] Test with real payment methods
- [ ] Monitor for 24 hours
- [ ] Document any issues

## Support and Maintenance

### Regular Tasks
- Monitor system health daily
- Review audit logs weekly
- Update dependencies monthly
- Backup data regularly
- Review security quarterly

### Key Metrics to Monitor
- Payment success rate (&gt; 98%)
- API response time (&lt; 1s)
- System uptime (&gt; 99.9%)
- User satisfaction scores
- Revenue growth trends

## Architecture Summary

The implementation follows a clean MVC architecture:

- **Model Layer**: Data management, business logic, external integrations
- **View Layer**: React components, user interfaces, admin dashboards
- **Controller Layer**: State management, workflow orchestration
- **Services**: Reusable business services and utilities
- **Middleware**: Security, performance, logging, monitoring

Total implementation: 15 comprehensive prompts covering every aspect of a production-ready payment system.</pre
            >
          </div>

          <div class="validation-box">
            <h4>‚úÖ Final Validation Steps:</h4>
            <ul>
              <li>Test complete admin dashboard functionality</li>
              <li>Verify role-based access control works correctly</li>
              <li>Check all analytics and monitoring displays</li>
              <li>Test alert resolution and management features</li>
              <li>Confirm audit log viewing and filtering</li>
              <li>Validate complete end-to-end payment system</li>
              <li>Run comprehensive security and performance tests</li>
              <li>Verify all documentation is complete and accurate</li>
            </ul>
          </div>

          <div class="next-steps">
            <h4>üéâ Implementation Complete!</h4>
            <p>
              Congratulations! You have successfully implemented a comprehensive, enterprise-grade
              Stripe payment system. The implementation includes all 15 prompts with detailed
              step-by-step instructions, covering everything from basic setup to advanced admin
              dashboards. Your payment system is now production-ready with security, compliance,
              monitoring, and analytics capabilities.
            </p>
          </div>
        </section>
      </div>

      <div class="summary-section" id="summary">
        <h2>üìä Implementation Summary</h2>
        <p>
          This comprehensive guide provides a complete, step-by-step implementation for integrating
          Stripe payments into the Business Scraper App. The implementation follows the project's
          MVC architecture, maintains security best practices, and includes comprehensive testing.
        </p>

        <div class="benefits-grid">
          <div class="benefit-item">
            <h4>üí∞ Monetization</h4>
            <p>Subscription tiers with feature-based access control</p>
          </div>
          <div class="benefit-item">
            <h4>üîí Security</h4>
            <p>PCI-compliant payment processing with audit logging</p>
          </div>
          <div class="benefit-item">
            <h4>üìà Analytics</h4>
            <p>Comprehensive business intelligence and reporting</p>
          </div>
          <div class="benefit-item">
            <h4>üöÄ Scalability</h4>
            <p>Production-ready with monitoring and alerting</p>
          </div>
          <div class="benefit-item">
            <h4>üéØ User Experience</h4>
            <p>Seamless onboarding and payment management</p>
          </div>
          <div class="benefit-item">
            <h4>‚ö° Performance</h4>
            <p>Optimized for high-volume payment processing</p>
          </div>
        </div>

        <div
          style="
            margin-top: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
          "
        >
          <h3>üéØ Key Achievements</h3>
          <ul style="margin-left: 20px">
            <li>
              <strong>15 Comprehensive Prompts:</strong> Complete implementation guide from setup to
              production
            </li>
            <li>
              <strong>Enterprise Architecture:</strong> Full MVC implementation with advanced
              payment services
            </li>
            <li><strong>Security & Compliance:</strong> GDPR, PCI DSS, and SOC 2 compliance</li>
            <li>
              <strong>Business Intelligence:</strong> Advanced analytics and reporting capabilities
            </li>
            <li>
              <strong>Production Ready:</strong> Monitoring, alerting, and performance optimization
            </li>
            <li><strong>Professional Quality:</strong> 2,000+ lines of implementation code</li>
          </ul>
        </div>

        <div style="text-align: center; margin-top: 30px">
          <p style="font-size: 1.2rem; opacity: 0.9">
            <strong>Total Implementation Time Estimate:</strong> 12-16 hours for an experienced
            developer
          </p>
        </div>
      </div>
    </div>

    <a href="#" class="back-to-top">‚Üë</a>

    <script>
      // Smooth scrolling for navigation links
      document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener('click', function (e) {
          e.preventDefault()
          const target = document.querySelector(this.getAttribute('href'))
          if (target) {
            target.scrollIntoView({
              behavior: 'smooth',
              block: 'start',
            })
          }
        })
      })

      // Back to top functionality
      document.querySelector('.back-to-top').addEventListener('click', function (e) {
        e.preventDefault()
        window.scrollTo({
          top: 0,
          behavior: 'smooth',
        })
      })

      // Show/hide back to top button
      window.addEventListener('scroll', function () {
        const backToTop = document.querySelector('.back-to-top')
        if (window.pageYOffset > 300) {
          backToTop.style.display = 'flex'
        } else {
          backToTop.style.display = 'none'
        }
      })
    </script>
  </body>
</html>
